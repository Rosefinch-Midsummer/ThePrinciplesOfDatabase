<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>数据库原理</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="前言.html"><strong aria-hidden="true">1.</strong> 前言</a></li><li class="chapter-item expanded affix "><li class="part-title">HIT 数据库系统</li><li class="chapter-item expanded "><a href="课程概述.html"><strong aria-hidden="true">2.</strong> 课程概述</a></li><li class="chapter-item expanded "><a href="第1讲-初步认识数据库系统.html"><strong aria-hidden="true">3.</strong> 第1讲-初步认识数据库系统</a></li><li class="chapter-item expanded "><a href="第2讲-数据库系统的结构抽象与演变.html"><strong aria-hidden="true">4.</strong> 第2讲-数据库系统的结构抽象与演变</a></li><li class="chapter-item expanded "><a href="第3讲-关系模型之基本概念.html"><strong aria-hidden="true">5.</strong> 第3讲-关系模型之基本概念</a></li><li class="chapter-item expanded "><a href="第4讲-关系模型之关系代数（基于集合）.html"><strong aria-hidden="true">6.</strong> 第4讲-关系模型之关系代数（基于集合）</a></li><li class="chapter-item expanded "><a href="第5讲-关系模型之关系演算（基于逻辑）.html"><strong aria-hidden="true">7.</strong> 第5讲-关系模型之关系演算（基于逻辑）</a></li><li class="chapter-item expanded "><a href="第6讲-SQL语言之概述.html"><strong aria-hidden="true">8.</strong> 第6讲-SQL语言之概述</a></li><li class="chapter-item expanded "><a href="第7讲-SQL语言之复杂查询与视图.html"><strong aria-hidden="true">9.</strong> 第7讲-SQL语言之复杂查询与视图</a></li><li class="chapter-item expanded "><a href="第8讲-SQL语言与数据库完整性和安全性.html"><strong aria-hidden="true">10.</strong> 第8讲-SQL语言与数据库完整性和安全性</a></li><li class="chapter-item expanded "><a href="第9讲-嵌入式SQL语言之基本技巧.html"><strong aria-hidden="true">11.</strong> 第9讲-嵌入式SQL语言之基本技巧</a></li><li class="chapter-item expanded "><a href="第10讲-嵌入式SQL语言之动态SQL.html"><strong aria-hidden="true">12.</strong> 第10讲-嵌入式SQL语言之动态SQL</a></li><li class="chapter-item expanded "><a href="第11讲-数据建模：思想与方法(暨数据库设计之抽象与表达方法).html"><strong aria-hidden="true">13.</strong> 第11讲-数据建模：思想与方法(暨数据库设计之抽象与表达方法)</a></li><li class="chapter-item expanded "><a href="第12讲-数据建模：工程化方法及案例分析.html"><strong aria-hidden="true">14.</strong> 第12讲-数据建模：工程化方法及案例分析</a></li><li class="chapter-item expanded "><a href="第13讲-数据库设计过程.html"><strong aria-hidden="true">15.</strong> 第13讲-数据库设计过程</a></li><li class="chapter-item expanded "><a href="第14讲-函数依赖及其公理定理.html"><strong aria-hidden="true">16.</strong> 第14讲-函数依赖及其公理定理</a></li><li class="chapter-item expanded "><a href="第15讲-关系模式设计之规范形式.html"><strong aria-hidden="true">17.</strong> 第15讲-关系模式设计之规范形式</a></li><li class="chapter-item expanded "><a href="第16讲-模式分解存在什么问题.html"><strong aria-hidden="true">18.</strong> 第16讲-模式分解存在什么问题</a></li><li class="chapter-item expanded "><a href="第17讲-数据库物理存储.html"><strong aria-hidden="true">19.</strong> 第17讲-数据库物理存储</a></li><li class="chapter-item expanded "><a href="第18讲-数据库索引技术.html"><strong aria-hidden="true">20.</strong> 第18讲-数据库索引技术</a></li><li class="chapter-item expanded "><a href="第19讲-数据库查询实现算法之一趟扫描算法.html"><strong aria-hidden="true">21.</strong> 第19讲-数据库查询实现算法之一趟扫描算法</a></li><li class="chapter-item expanded "><a href="第20讲-数据库查询实现算法之两趟扫描算法.html"><strong aria-hidden="true">22.</strong> 第20讲-数据库查询实现算法之两趟扫描算法</a></li><li class="chapter-item expanded "><a href="第21讲-数据库查询优化技术.html"><strong aria-hidden="true">23.</strong> 第21讲-数据库查询优化技术</a></li><li class="chapter-item expanded "><a href="第22讲-数据库事务处理技术之并发控制.html"><strong aria-hidden="true">24.</strong> 第22讲-数据库事务处理技术之并发控制</a></li><li class="chapter-item expanded "><a href="第23讲-数据库事务处理技术之故障恢复.html"><strong aria-hidden="true">25.</strong> 第23讲-数据库事务处理技术之故障恢复</a></li><li class="chapter-item expanded affix "><li class="part-title">附加内容</li><li class="chapter-item expanded "><a href="存储过程.html"><strong aria-hidden="true">26.</strong> 存储过程</a></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">数据库原理</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="前言"><a class="header" href="#前言">前言</a></h1>
<p>本仓库记录了数据库相关内容的学习过程，主要包括 HIT 战德臣教授在中国大学 MOOC 平台开设的《数据库系统》课程，以后也会增加一些 MySQL、Redis等数据库的内容。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="课程概述"><a class="header" href="#课程概述">课程概述</a></h1>
<p>《数据库系统》不仅是计算机、软件工程等专业的核心课程，而且也是非计算机专业学生必修的信息技术课程。当前互联网+大数据，一切都建立在数据库之上，以数据说话，首先需要聚集数据、需要分析和管理数据。数据库技术已成为各种计算系统的核心技术，数据库相关知识也已成为每个人必须掌握的知识。—— 课程团队</p>
<h2 id="课程链接"><a class="header" href="#课程链接">课程链接</a></h2>
<p><a href="https://www.icourse163.org/course/0809HIT026A-1001516002">数据库系统（上）：模型与语言</a></p>
<p><a href="https://www.icourse163.org/course/HIT-1001554030">数据库系统（中）：建模与设计</a></p>
<p><a href="https://www.icourse163.org/course/0809HIT026C-1001578001">数据库系统（下）：管理与技术</a></p>
<h2 id="课程目标"><a class="header" href="#课程目标">课程目标</a></h2>
<p>本系列课程旨在使学生充分掌握数据库系统的基本概念和基本原理，熟练掌握数据库系统语言、数据库抽象与建模方法和数据库应用程序设计方法，培养学生在信息管理和信息系统方面的抽象、设计、开发、应用和管理能力。同时，数据存储、数据库查询实现、查询优化、事务处理等技术，这些内容也是计算机学科学生在专业方面必须掌握的操纵数据库的能力，本课程也将为你详细讲授。</p>
<p>本课程将分为四个部分进行介绍：</p>
<p>一、基本知识与关系模型；</p>
<p>二、数据库语言及其应用；</p>
<p>三、数据建模与数据库设计；</p>
<p>四、数据库管理系统实现技术。</p>
<p>这四部分内容之间的关系如下图示意。</p>
<p><img src="https://nos.netease.com/edu-image/8AB07C7B30FA574B3C370D8BD63E5089.jpg?imageView&amp;thumbnail=520x520&amp;quality=100" alt="" /></p>
<p>这四部分内容将分为三门系列课程来开放。本课程《数据库系统（上）-模型与语言》将包括第一部分和第二部分内容。学习完本课程后，你可选择继续学习《数据库系统》系列课程的第二门《数据库系统（中）-建模与设计》或者选择继续学习《数据库系统》系列课程的第三门《数据库系统（下）-管理与技术》，这两门课为高阶课程，可以结合你的需求选择学习。</p>
<p><strong>本系列课程的特色</strong>：(1)本课程是一门<strong>理论性为基础、应用性为目标，理论应用相结合</strong>的计算机类主干课程；(2)<strong>抽象内容的实例化讲解</strong>是本课程的特色，通过大量具体示例，来阐释数据库相关的抽象概念和原理；(3)<strong>知识学习与案例点评相结合</strong>是本课程的特色，本课程包含数据建模和数据库设计相关的内容，重要的是知识的运用，案例点评则成为知识运用能力训练的重要手段； (4)<strong>问题导引的知识学习</strong>是本课程的特色，深入浅出，图文并茂，案例配合，面向问题地阐释数据库系统的核心内容。本课程将为学生从事大型信息系统软件的设计、开发和应用打下基础，也将为学生今后从事大规模数据的存储、操纵和分析奠定很好的基础。</p>
<p><strong>参考教材：</strong></p>
<p><strong>–1. Database System Concepts(数据库系统概念，有中译本), 7th Edition, 机械工业出版社，2021.</strong></p>
<p><strong>2. Database System Implementation(数据库系统实现，有中译本), 2nd Edition, 机械工业出版社，2010.</strong></p>
<p><strong>–3. Database:  Principles,Programming,and Performance(数据库：原理、编程与性能，有中译本), 2nd Edition，Patrick O’Neil, Elizabeth O’Neil，高等教育出版社，2001。</strong></p>
<p><strong>注：数据库系统的经典教材有很多，同学可任选一本作为主教材，其他可作为辅助教材。建议必备前面的第1和2两本教材，这两本教材并不重复。第1本教材是较为全面的数据库系统的教材，而第2本教材则是数据库管理系统实现技术的教材。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第1讲-初步认识数据库系统"><a class="header" href="#第1讲-初步认识数据库系统">第1讲-初步认识数据库系统</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322135616.png" alt="" /></p>
<h2 id="000-数据库系统课程简要介绍9分47秒"><a class="header" href="#000-数据库系统课程简要介绍9分47秒">000-数据库系统课程简要介绍（9分47秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322134131.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322134232.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322134350.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322134508.png" alt="" /></p>
<h2 id="100-本讲学习什么1分40秒及第1讲教学课件pdf"><a class="header" href="#100-本讲学习什么1分40秒及第1讲教学课件pdf">100-本讲学习什么（1分40秒）及第1讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322134607.png" alt="" /></p>
<h2 id="101-为什么要学习数据库系统4分41秒"><a class="header" href="#101-为什么要学习数据库系统4分41秒">101-为什么要学习数据库系统（4分41秒）</a></h2>
<h2 id="102-什么是数据库7分11秒"><a class="header" href="#102-什么是数据库7分11秒">102-什么是数据库（7分11秒）</a></h2>
<p>数据库是电子化信息的集合。</p>
<p>E.F.Codd，基于对“表（Table）”的理解：</p>
<ul>
<li>提出了“关系”及关系模型</li>
<li>提出了关系数据库理论</li>
<li>开创了数据库的时代</li>
<li>当前普遍应用的数据库管理系统的奠基者</li>
<li>获得了计算机领域最高奖“图灵奖“</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322134914.png" alt="" /></p>
<p>Database：相互之间有关联关系的Table的集合</p>
<h2 id="103-什么是数据库系统6分25秒"><a class="header" href="#103-什么是数据库系统6分25秒">103-什么是数据库系统（6分25秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322135017.png" alt="" /></p>
<h2 id="104-从用户角度看数据库管理系统9分39秒"><a class="header" href="#104-从用户角度看数据库管理系统9分39秒">104-从用户角度看数据库管理系统（9分39秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322135046.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322135140.png" alt="" /></p>
<h2 id="105-从系统角度看数据库管理系统9分51秒"><a class="header" href="#105-从系统角度看数据库管理系统9分51秒">105-从系统角度看数据库管理系统（9分51秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322135249.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322135335.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322135357.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322135422.png" alt="" /></p>
<h2 id="106-数据库系统课程学习什么9分43秒"><a class="header" href="#106-数据库系统课程学习什么9分43秒">106-数据库系统课程学习什么（9分43秒）</a></h2>
<h2 id="第1讲模拟练习题"><a class="header" href="#第1讲模拟练习题">第1讲模拟练习题</a></h2>
<p>数据库管理系统是软件产品，而数据库系统不仅仅是软件产品</p>
<p>数据库系统的构成包括数据库、数据库管理系统、数据库应用程序、数据库管理员以及计算机与网络基本系统</p>
<p>数据库管理系统就是通过数据库语言让用户操作进而提供数据库定义、数据库操纵和数据库控制功能的系统，同时提供了一系列程序能够实现对数据库的各种存储与维护</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第2讲-数据库系统的结构抽象与演变"><a class="header" href="#第2讲-数据库系统的结构抽象与演变">第2讲-数据库系统的结构抽象与演变</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322190453.png" alt="" /></p>
<h2 id="200-本讲学习什么1分39秒及第2讲教学课件pdf"><a class="header" href="#200-本讲学习什么1分39秒及第2讲教学课件pdf">200-本讲学习什么（1分39秒）及第2讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322183234.png" alt="" /></p>
<h2 id="201-数据库系统的标准结构15分15秒"><a class="header" href="#201-数据库系统的标准结构15分15秒">201-数据库系统的标准结构（15分15秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322184538.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322184618.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322184646.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322184708.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322184750.png" alt="" /></p>
<h2 id="202-什么是数据模型11分41秒"><a class="header" href="#202-什么是数据模型11分41秒">202-什么是数据模型（11分41秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322184947.png" alt="" /></p>
<p>三大经典数据模型：</p>
<ul>
<li>关系模型：表的形式组织数据</li>
<li>层次模型：树的形式组织数据</li>
<li>网状模型：图的形式组织数据</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322185202.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322185251.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322185319.png" alt="" /></p>
<h2 id="203-数据库系统的演变15分05秒"><a class="header" href="#203-数据库系统的演变15分05秒">203-数据库系统的演变（15分05秒）</a></h2>
<p>（1）简要发展史</p>
<p>（2）由文件系统到数据库</p>
<p>（3）由层次模型数据库、网状模型数据库到关系数据库</p>
<p>（4）由关系数据库到对象关系数据库、面问对象数据库</p>
<p>（5）由多种多样的数据库到多数据库开放式互连</p>
<p>（6）由普通数据库到与各种先进技术结合所形成的新型数据库</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322190140.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322190159.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322190215.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240322190254.png" alt="" /></p>
<h2 id="第2讲模拟练习题"><a class="header" href="#第2讲模拟练习题">第2讲模拟练习题</a></h2>
<p><strong>数据库系统的数据独立性是指不会因为系统数据存储结构与数据逻辑结构的变化而影响应用程序。</strong></p>
<p>概念模式到内模式的映像实现了数据的物理独立性</p>
<p>外模式到概念模式的映像实现了数据的逻辑独立性</p>
<p>别名一览表：</p>
<div class="table-wrapper"><table><thead><tr><th>External Schema</th><th>Conceptual Schema</th><th>Internal Schema</th></tr></thead><tbody>
<tr><td>用户模式、局部模式、外模式</td><td>概念模式、全局模式、逻辑模式</td><td>存储模式、内模式、物理模式</td></tr>
<tr><td>视图默认指用户视图。</td><td>模式默认指概念模式。</td><td></td></tr>
</tbody></table>
</div><div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第3讲-关系模型之基本概念"><a class="header" href="#第3讲-关系模型之基本概念">第3讲-关系模型之基本概念</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323151331.png" alt="" /></p>
<h2 id="300-本讲学习什么44秒及第3讲教学课件pdf"><a class="header" href="#300-本讲学习什么44秒及第3讲教学课件pdf">300-本讲学习什么（44秒）及第3讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323134049.png" alt="" /></p>
<h2 id="301-什么是关系模型10分50秒"><a class="header" href="#301-什么是关系模型10分50秒">301-什么是关系模型（10分50秒）</a></h2>
<p>关系模型</p>
<ul>
<li>最早由E.F.Codd在1970年提出</li>
<li>是从表（Table）及表的处理方式中抽象出来的，是在对传统表及其操作进行数学化严格定义基础上，引入集合理论与逻辑学理论提出的</li>
<li>是数据库的三大经典数据模型之一，也是现在大多数商品化数据库系统所仍然使用的数据模型</li>
<li>标准的数据库语言（SQL语言）是建立在关系模型基础之上的，数据库领域的众多理论也都是建立在关系模型基础之上的</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323135011.png" alt="" /></p>
<p>关系运算：关系代数和关系演算；关系演算：元组演算和域演算。</p>
<p>关系代数示例：基于集合的运算</p>
<p>即：操作的对象及结果都是集合，是一次一集合（Set-at-a-time）的操作。而非关系型的数据操作通常是一次一记录（Record-at-a-time）的操作</p>
<p>元组演算示例：基于逻辑的运算</p>
<p>域演算示例：基于示例的运算</p>
<h2 id="302-什么是关系13分26秒"><a class="header" href="#302-什么是关系13分26秒">302-什么是关系（13分26秒）</a></h2>
<p>为什么把“表”称为关系？</p>
<p>怎样严格定义一个“表”？</p>
<p>“表”和“关系”有什么异同？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323141950.png" alt="" /></p>
<p>标题/模式：对应于定义 Table 的 SQL 语句</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323142105.png" alt="" /></p>
<p>在关系模型中，域名是指关系中的每一列的数据类型，即此列中的数据的取值范围。例如，在一个名为“学生”的关系中，可能会有一个字段（域名）叫做“学生姓名”，其域可能是字符串类型；另一个字段叫做“学生年龄”，其域可能是整数类型。</p>
<p>而属性名则是指关系中各个字段的名称，即每一列的标题。继续以“学生”关系为例，其中可能包含“学生姓名”和“学生年龄”两个属性，分别对应关系中的两列数据。</p>
<p>总结来说，域名指的是数据类型，即数据的取值范围，而属性名则指的是字段的名称，即列的标题。在关系数据库设计中，域名和属性名是设计关系模型时需要考虑的两个重要因素。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323142133.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323142228.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323142251.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323142338.png" alt="" /></p>
<p>关系模式 R(A1:D1, A2:D2, ... ,An:Dn) 中属性向域的映象在很多 DBMS 中一般直接说明为属性的类型、长度等。例如：<code>Student(S# char(8), Sname char(10), Ssex char(2), Sage integer,D# char(2), Sclass char(6));</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323142703.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323142737.png" alt="" /></p>
<h2 id="303-关系有什么特性7分12秒"><a class="header" href="#303-关系有什么特性7分12秒">303-关系有什么特性（7分12秒）</a></h2>
<p>特性：</p>
<p>1、列是同质的：即每一列中的分量来自同一域，是同一类型的数据</p>
<p>2、不同的列可来自同一个域，称其中的每一列为一个属性，不同的属性要给予不同的属性名。</p>
<p>3、列位置互换性、行位置互换性</p>
<p>4、关系的任何两个元组不能完全相同</p>
<p>5、属性不可再分</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323142927.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323143029.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323143132.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323143155.png" alt="" /></p>
<h2 id="304-候选码与外码10分16秒"><a class="header" href="#304-候选码与外码10分16秒">304-候选码与外码（10分16秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323143344.png" alt="" /></p>
<p><strong>有时，关系中有很多组候选码</strong>，例如：</p>
<p>学生(S#，Sname，Sage，Sclass，Saddress)</p>
<p>其中属性S#是候选码，属性组（Sname，Saddress）也是候选码（同名同地址的两个同学是不存在的</p>
<p>再如：</p>
<p>Employee(EmplD, EmpName, Mobile)</p>
<p>每一雇员有唯一的 EmpID，没有两个雇员有相同的手机号 Mobile ，则EmplD是候选码，Mobile也是候选码</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323143649.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323145742.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323145803.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323145846.png" alt="" /></p>
<h2 id="305-关系模型的完整性7分50秒"><a class="header" href="#305-关系模型的完整性7分50秒">305-关系模型的完整性（7分50秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323150300.png" alt="" /></p>
<p>空值的含义</p>
<p>空值：不知道、不存在或无意义的值；</p>
<p>在进行关系操作时，有时关系中的某属性值在当前是填不上的，比如档案中有“生日不详”、“下落不明”、“日程尚待公布”等，这时就需要空值来代表这种情况。关系模型中用“？表征</p>
<p>数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p>
<p>例如：<code>"3+?"</code>结果是多少呢？<code>"3*?"</code>结果是多少呢？<code>"? and (A=A)</code> 结果又是多少呢？</p>
<p>再例如，一个班有30名同学，如所有同学都有成绩，则可求出平均成绩；如果有一个同学没有成绩，怎样参与平均成绩的计算呢，是当作0，还是当作100呢？还是不考虑他呢？</p>
<p>有空值的时候是需要特殊处理的，要特别注意。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323151200.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240323151227.png" alt="" /></p>
<p>DBMS对关系完整性的支持</p>
<p>实体完整性和参照完整性由DBMS系统自动支持</p>
<p>DBMS系统通常提供了如下机制：</p>
<p>（1）它使用户可以自行定义有关的完整性约束条件；</p>
<p>（2）当有更新操作发生时，DBMS将自动按照完整性约束条件检验更新操作的正确性，即是否符合用户自定义的完整性</p>
<h2 id="第3讲模拟练习题"><a class="header" href="#第3讲模拟练习题">第3讲模拟练习题</a></h2>
<p>概念理解题目：</p>
<p>1<strong>某关系R的外键是指其它关系的候选键，可以是R中的主属性或非主属性</strong></p>
<p>2<strong>关系模型中，下列关于候选键说法正确的是可由其值能惟一标识该关系中任何元组的一个或多个属性组成</strong></p>
<p>关系是以内容(名字或值)来区分的</p>
<p>区分哪一列是靠列名</p>
<p>区分哪一行是靠某一或某几列的值</p>
<p>21<strong>关于“关系”的说法，正确的是关系是一个由行与列组成的、能够表达数据及数据之间联系的二维表。</strong></p>
<p>25<strong>参照完整性规则是指表的外键必须是另一个表主键的有效值，或者是空值。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第4讲关系模型之关系代数基于集合"><a class="header" href="#第4讲关系模型之关系代数基于集合">第4讲关系模型之关系代数（基于集合）</a></h1>
<h2 id="400-本讲学习什么1分13秒及第4讲教学课件pdf"><a class="header" href="#400-本讲学习什么1分13秒及第4讲教学课件pdf">400-本讲学习什么（1分13秒）及第4讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320131634.png" alt="" /></p>
<h2 id="401-什么是关系代数5分40秒"><a class="header" href="#401-什么是关系代数5分40秒">401-什么是关系代数（5分40秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320132019.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320132040.png" alt="" /></p>
<h2 id="402-并相容性的概念2分03秒"><a class="header" href="#402-并相容性的概念2分03秒">402-并相容性的概念（2分03秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320133109.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320133130.png" alt="" /></p>
<h2 id="403-并操作3分38秒"><a class="header" href="#403-并操作3分38秒">403-并操作（3分38秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320133242.png" alt="" /></p>
<h2 id="404-差操作3分17秒"><a class="header" href="#404-差操作3分17秒">404-差操作（3分17秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320133307.png" alt="" /></p>
<h2 id="405-广义积操作5分29秒"><a class="header" href="#405-广义积操作5分29秒">405-广义积操作（5分29秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320133546.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320133609.png" alt="" /></p>
<p>广义积操作（语义的）</p>
<p>当一个检索涉及多个表时（如学生表和课程表），便需要将这些表串接或拼接起来，然后才能检索，这时，就要使用广义笛卡尔积运算。</p>
<p>广义积操作是后面学习各种连接运算的基础。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320134016.png" alt="" /></p>
<h2 id="406-选择操作9分52秒"><a class="header" href="#406-选择操作9分52秒">406-选择操作（9分52秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320134043.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320134557.png" alt="" /></p>
<h2 id="407-投影操作及基本操作小结6分27秒"><a class="header" href="#407-投影操作及基本操作小结6分27秒">407-投影操作及基本操作小结（6分27秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320135426.png" alt="" /></p>
<h2 id="408-交操作3分54秒"><a class="header" href="#408-交操作3分54秒">408-交操作（3分54秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320140059.png" alt="" /></p>
<h2 id="409-theta连接操作及更名操作12分09秒"><a class="header" href="#409-theta连接操作及更名操作12分09秒">409-theta连接操作及更名操作（12分09秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320140029.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320141236.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320141343.png" alt="" /></p>
<h2 id="410-自然连接操作6分59秒"><a class="header" href="#410-自然连接操作6分59秒">410-自然连接操作（6分59秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240320141556.png" alt="" /></p>
<h2 id="411-应用关系代数操作训练14分48秒"><a class="header" href="#411-应用关系代数操作训练14分48秒">411-应用关系代数操作训练（14分48秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321184223.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321184357.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321184518.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321185346.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321185433.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321185500.png" alt="" /></p>
<h2 id="412-除操作16分24秒"><a class="header" href="#412-除操作16分24秒">412-除操作（16分24秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321185800.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321191142.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321191205.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321192122.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321192150.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321192237.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321192346.png" alt="" /></p>
<h2 id="413-外连接操作8分53秒"><a class="header" href="#413-外连接操作8分53秒">413-外连接操作（8分53秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321220410.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321220434.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321220452.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321220518.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240321220558.png" alt="" /></p>
<h2 id="第4讲模拟练习题"><a class="header" href="#第4讲模拟练习题">第4讲模拟练习题</a></h2>
<p>3<strong>自然连接是构成新关系的有效方法。一般情况下，当对关系R和S使用自然连接时，要求R和S含有一个或多个共有的属性</strong></p>
<p>7<strong>关系R与关系S只有一个公共属性，T1是R与S做θ连接的结果，T2是R与S自然连接的结果，则下列说法正确的是T1的属性个数大于T2的属性个数</strong></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第5讲-关系模型之关系演算--基于逻辑"><a class="header" href="#第5讲-关系模型之关系演算--基于逻辑">第5讲 关系模型之关系演算  （基于逻辑）</a></h1>
<h2 id="500-本讲学习什么1分47秒及第5讲教学课件pdf"><a class="header" href="#500-本讲学习什么1分47秒及第5讲教学课件pdf">500-本讲学习什么（1分47秒）及第5讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240316163204.png" alt="" /></p>
<h2 id="501-什么是关系元组演算6分44秒"><a class="header" href="#501-什么是关系元组演算6分44秒">501-什么是关系元组演算（6分44秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240316164342.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240316164435.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240316164458.png" alt="" /></p>
<p>其中 <span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.6944em;"></span><span class="mord mathnormal" style="margin-right:0.02778em;">θ</span></span></span></span> 是比较运算符</p>
<h2 id="502-简单运用元组演算公式9分17秒"><a class="header" href="#502-简单运用元组演算公式9分17秒">502-简单运用元组演算公式（9分17秒）</a></h2>
<p>（1）元组演算公式之原子公式</p>
<p>（2）元组演算公式之与、或、非运算符</p>
<p>（3）注意运算符之次序及语义正确性</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240316170636.png" alt="" /></p>
<h2 id="503-存在量词与全称量词17分17秒"><a class="header" href="#503-存在量词与全称量词17分17秒">503-存在量词与全称量词（17分17秒）</a></h2>
<p>元组变量t前有存在量词或全称量词，则该变量被称为“约束变量”，否则被称为“自由变量”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240316185712.png" alt="" /></p>
<p>战老师认为这两个公式含义有所不同。</p>
<h2 id="504-等价变换8分40秒"><a class="header" href="#504-等价变换8分40秒">504-等价变换（8分40秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317155051.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317155120.png" alt="" /></p>
<p>注意：判断未学过某门课程需要遍历所有相关的课程</p>
<h2 id="505-四个典型示例12分39秒"><a class="header" href="#505-四个典型示例12分39秒">505-四个典型示例（12分39秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317162116.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317162140.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317162201.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317162220.png" alt="" /></p>
<h2 id="506-用元组演算实现关系代数操作4分35秒"><a class="header" href="#506-用元组演算实现关系代数操作4分35秒">506-用元组演算实现关系代数操作（4分35秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317162742.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317162802.png" alt="" /></p>
<h2 id="507-什么是域演算7分58秒"><a class="header" href="#507-什么是域演算7分58秒">507-什么是域演算（7分58秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317165123.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317165145.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317165207.png" alt="" /></p>
<h2 id="508-什么是按示例查询-qbe12分54秒"><a class="header" href="#508-什么是按示例查询-qbe12分54秒">508-什么是按示例查询-QBE（12分54秒）</a></h2>
<p>QBE：Query By Example</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317170037.png" alt="" /></p>
<h2 id="509-qbe应用训练10分52秒"><a class="header" href="#509-qbe应用训练10分52秒">509-QBE应用训练（10分52秒）</a></h2>
<h2 id="510-关系演算的安全性7分06秒"><a class="header" href="#510-关系演算的安全性7分06秒">510-关系演算的安全性（7分06秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317170849.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317170923.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317170951.png" alt="" /></p>
<h2 id="511-三种关系运算之比较6分21秒"><a class="header" href="#511-三种关系运算之比较6分21秒">511-三种关系运算之比较（6分21秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317171038.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240317171100.png" alt="" /></p>
<p>数据库语言可以基于这三种抽象运算来设计</p>
<ul>
<li>用“键盘符号”来替换抽象的数学符号</li>
<li>用易于理解的符号组合来表达抽象的数学符号</li>
</ul>
<h2 id="第5讲模拟练习题"><a class="header" href="#第5讲模拟练习题">第5讲模拟练习题</a></h2>
<p>安全的元组演算公式和安全的域演算公式可以等价变换。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第6讲-sql语言之概述"><a class="header" href="#第6讲-sql语言之概述">第6讲-SQL语言之概述</a></h1>
<h2 id="600-本讲学习什么2分38秒及第6讲教学课件pdf"><a class="header" href="#600-本讲学习什么2分38秒及第6讲教学课件pdf">600-本讲学习什么（2分38秒）及第6讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318154835.png" alt="" /></p>
<h2 id="601-sql语言概述8分31秒"><a class="header" href="#601-sql语言概述8分31秒">601-SQL语言概述（8分31秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318155249.png" alt="" /></p>
<h2 id="602-利用sql建立数据库16分44秒"><a class="header" href="#602-利用sql建立数据库16分44秒">602-利用SQL建立数据库(16分44秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318160928.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318161014.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318161032.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318161058.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318161129.png" alt="" /></p>
<h2 id="603-利用sql进行基本查询13分55秒"><a class="header" href="#603-利用sql进行基本查询13分55秒">603-利用SQL进行基本查询(13分55秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318161209.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318164846.png" alt="" /></p>
<p>当要查询既学过001课程又学过002课程的学生的学号时，我们可以使用SQL的交集操作来实现。下面是相应的SQL语句：</p>
<pre><code class="language-sql">SELECT student_id
FROM course_enrollment
WHERE course_id = '001'
INTERSECT
SELECT student_id
FROM course_enrollment
WHERE course_id = '002';
</code></pre>
<p>这段SQL语句的含义是，首先从包含课程选课信息的表course_enrollment中选择学过001课程的学生的学号，然后取这部分学生和学过002课程的学生的学号做交集操作，最终得到既学过001课程又学过002课程的学生的学号集合。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318164948.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318165006.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240318165025.png" alt="" /></p>
<p>SQL 通配符</p>
<p>通配符可用于替代字符串中的任何其他字符。</p>
<p>在 SQL 中，通配符与 SQL LIKE 操作符一起使用。</p>
<p>SQL 通配符用于搜索表中的数据。</p>
<p>在 SQL 中，可使用以下通配符：</p>
<div class="table-wrapper"><table><thead><tr><th>通配符</th><th>描述</th></tr></thead><tbody>
<tr><td>%</td><td>替代 0 个或多个字符</td></tr>
<tr><td>_</td><td>替代一个字符</td></tr>
<tr><td>[<em>charlist</em>]</td><td>字符列中的任何单一字符</td></tr>
<tr><td>[^<em>charlist</em>]  <br>或  <br>[!<em>charlist</em>]</td><td>不在字符列中的任何单一字符</td></tr>
<tr><td></td><td></td></tr>
<tr><td>MySQL 中使用 <strong>REGEXP</strong> 或 <strong>NOT REGEXP</strong> 运算符 (或 RLIKE 和 NOT RLIKE) 来操作正则表达式。</td><td></td></tr>
</tbody></table>
</div>
<p>下面的 SQL 语句选取 name 以 "G"、"F" 或 "s" 开始的所有网站：</p>
<pre><code class="language-sql">SELECT * FROM Websites  
WHERE name REGEXP '^[GFs]';
</code></pre>
<h2 id="604-利用sql进行多表联合查询14分11秒"><a class="header" href="#604-利用sql进行多表联合查询14分11秒">604-利用SQL进行多表联合查询(14分11秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319181917.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319182047.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319182141.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319184800.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319184822.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319184852.png" alt="" /></p>
<p>要查询没学过李明老师课程的所有学生的学号，我们可以使用SQL的差集操作来实现。下面是相应的SQL语句：</p>
<pre><code class="language-sql">SELECT student_id
FROM all_students
EXCEPT
SELECT student_id
FROM course_enrollment
WHERE teacher_name = '李明';
</code></pre>
<p>这段SQL语句的含义是，首先从包含所有学生信息的表all_students中选择所有学生的学号，然后从课程选课信息表course_enrollment中选择学过李明老师课程的学生的学号，最后取这两部分学生的学号集合做差集操作，得到所有没学过李明老师课程的学生的学号集合。</p>
<h2 id="605-结合select的insert语句7分35秒"><a class="header" href="#605-结合select的insert语句7分35秒">605-结合SELECT的INSERT语句(7分35秒)</a></h2>
<p>元组新增Insert：新增一个或一些元组到数据库的Table中</p>
<p>元组更新Update：对某些元组中的某些属性值进行重新设定</p>
<p>元组删除Delete：删除某些元组</p>
<p>SOL-DML既能单一记录操作，也能对记录集合进行批更新操作</p>
<p>SQL-DML之更新操作需要利用前面介绍的子查询（Subquery）的概念，以便处理“一些”、“某些”等。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319201313.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319201343.png" alt="" /></p>
<h2 id="606-结合select的delete与update语句7分20秒"><a class="header" href="#606-结合select的delete与update语句7分20秒">606-结合SELECT的DELETE与UPDATE语句(7分20秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319201416.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319201441.png" alt="" /></p>
<h2 id="607-数据库定义的修正与撤销4分55秒"><a class="header" href="#607-数据库定义的修正与撤销4分55秒">607-数据库定义的修正与撤销(4分55秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319201529.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240319201558.png" alt="" /></p>
<p>撤消数据库</p>
<p><code>drop database 数据库名；</code></p>
<p>示例：撤消SCT数据库</p>
<p><code>Drop database SCT;</code></p>
<p>有些DBMS提供了操作多个数据库的能力，此时在进行数据库操作时需要指定待操作数据库与关闭数据库的功能</p>
<p>指定当前数据库</p>
<p><code>use 数据库名；</code></p>
<p>关闭当前数据库</p>
<p><code>close 数据库名;</code></p>
<h2 id="第6讲模拟练习题"><a class="header" href="#第6讲模拟练习题">第6讲模拟练习题</a></h2>
<p>易错点：</p>
<p>字符串型属性值需要加引号</p>
<p>“%”匹配零个或多个字符，所以不仅能匹配“张某某”也能匹配“张”和“张某”</p>
<p>7<strong>有关系表SC ( S# , C#, Score)，求既学过“001”号课又学过 “002”号课的所有学生的学号，下列SQL语句正确的是<code>Select S1.S# From SC S1, SC S2 Where S1.S# = S2.S# and S1.C#=‘001’ and  S2.C#=‘002 ;</code>。</strong></p>
<p>17<strong>已知关系S(S#,SN,AGE,SEX),SC(C#,S#,GRADE),C(C#,CN,TEACHER)。若要检索学生姓名及其选修课程的课程号和成绩，正确的SELECT语句是<code>SELECT S.SN,SC.C#,SC.GRADE FROM S,SC WHERE S.S#=SC.S#</code>。</strong> （注意：这里要明确指出连接操作）</p>
<p>学得不好的点：</p>
<p>11<strong>学生关系S（S#,Sname,Ssex,Sage,D#,Sclass）,S的属性分别表示学生的学号、姓名、性别、年龄。要在表S中删除一个属性“年龄”，可选用的SQL语句是<code>ALTER  TABLE  S  DROP  Sage</code>。</strong></p>
<p>15<strong>查询结果输出时要求按“总评成绩”降序排列，相同者按“性别”升序，正确的子句是<code>ORDER BY 总评成绩 DESC,性别</code>。</strong></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第7讲-sql语言之复杂查询与视图"><a class="header" href="#第7讲-sql语言之复杂查询与视图">第7讲-SQL语言之复杂查询与视图</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325152118.png" alt="" /></p>
<h2 id="700-本讲学习什么1分25秒及第7讲教学课件pdf"><a class="header" href="#700-本讲学习什么1分25秒及第7讲教学课件pdf">700-本讲学习什么（1分25秒）及第7讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325121911.png" alt="" /></p>
<h2 id="701-in子查询11分47秒"><a class="header" href="#701-in子查询11分47秒">701-IN子查询(11分47秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325132439.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325132525.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325132623.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325132725.png" alt="" /></p>
<h2 id="702-thetasome子查询12分53秒"><a class="header" href="#702-thetasome子查询12分53秒">702-ThetaSome子查询(12分53秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325132755.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325132828.png" alt="" /></p>
<p>为什么不用 Theta-any？</p>
<p>在SQL标准中，也有 Theta-any 谓词，但由于其语义的模糊性：any，“任一”是指所有呢？还是指某一个？不清楚，所以被 Theta-some 替代以求更明晰。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325133058.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325133132.png" alt="" /></p>
<h2 id="703-exists子查询11分48秒"><a class="header" href="#703-exists子查询11分48秒">703-Exists子查询(11分48秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325133209.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325133257.png" alt="" /></p>
<p>当在 SQL 中使用 IN 和 EXISTS 时，它们的主要区别在于它们的执行方式和用途。IN 子查询会将结果集与主查询进行比较，而 EXISTS 子查询只需检查子查询是否返回任何行即可。</p>
<p>下面是一个简单的示例来展示 IN 和 EXISTS 的区别：</p>
<p>使用 IN：</p>
<p><code>SELECT *  FROM table1 WHERE column1 IN (SELECT column2 FROM table2);</code></p>
<p>使用 EXISTS：</p>
<p><code>SELECT *  FROM table1 t1 WHERE EXISTS (SELECT 1 FROM table2 t2 WHERE t1.column1 = t2.column2);</code></p>
<p>关于 IN 和 EXISTS 的更多详细信息，请参考以下链接：</p>
<ol>
<li><a href="https://www.geeksforgeeks.org/in-vs-exists-in-sql/">IN vs EXISTS in SQL</a></li>
<li><a href="https://www.sqlshack.com/difference-between-in-and-exists-in-sql-server/">Difference between IN and EXISTS in S</a></li>
</ol>
<p>子查询表小的用in，子查询表大的用exists。</p>
<p><a href="https://blog.csdn.net/taomeechildren/article/details/128922688">从原理浅析MySQL中exists和in的区别（如何选用exists和in）</a></p>
<p>但执行过程的区别在于：</p>
<p>exists子句会对外表（即t1）用loop逐条记录查询，每次查询都会查看exists中的select语句，如果select子句返回记录行（无论返回记录行是多少，只要能返回），exists就会返回true，则外表中的当前记录就会被检索出来；如果select子句没有返回记录行，exists就会返回false，则外表中的当前记录就会被丢弃。——exist子句循环每次取出外表中的一条记录用来执行exists中的语句查内表，是先查外表，再查内表（相关子查询）。</p>
<p>in查询相当于多个or条件的叠加。in子句需要先将子查询的记录全部查出来。注意in子句中的子查询返回的结果集必须只有一个字段。假设子查询返回的结果集有m条记录，在进行m次查询。——in子句是先执行in中的子句查出来内表的结果，然后外表针对内表查出来的结果一个个遍历匹配。即先查内表，再查外表（不相关子查询）。</p>
<p>基于以上的认识：</p>
<p>exists只有内表可以用上索引，外层循环必须要走一个遍历过程；而in内表和外表都可以用上索引，因为in本质上属于多个条件查询的并集(or)。</p>
<p>如何选用exists和in？</p>
<p>当两个表的大小相当时，用exists和in的效率差别不大。</p>
<p>如果两个表一个大一个小，则子查询表(即内表)大的用exists，子查询表(即内表)小的用in。
其实就是”小表驱动大表“的思想：用exist时外表是驱动表，用in时内表是驱动表。</p>
<p>MySQL的外连接就利用了”小表驱动大表“的思想做自动优化，因此有时候会发现LEFT JOIN左侧的不是驱动表而是被驱动表，其实就是MySQL优化器的功能。同理，内连接也有类似的情况。</p>
<h2 id="704-结果计算与聚集计算6分57秒"><a class="header" href="#704-结果计算与聚集计算6分57秒">704-结果计算与聚集计算(6分57秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325145109.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325145215.png" alt="" /></p>
<h2 id="705-分组聚集计算与分组过滤10分38秒"><a class="header" href="#705-分组聚集计算与分组过滤10分38秒">705-分组聚集计算与分组过滤(10分38秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325145247.png" alt="" /></p>
<p>GROUP BY 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。</p>
<p>SQL GROUP BY 语法：</p>
<pre><code class="language-sql">SELECT column_name, aggregate_function(column_name)  
FROM table_name  
WHERE column_name operator value  
GROUP BY column_name;
</code></pre>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325145340.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325145403.png" alt="" /></p>
<p>在 SQL 中增加 HAVING 子句原因是，WHERE 关键字无法与聚合函数一起使用。</p>
<p>HAVING 子句可以让我们筛选分组后的各组数据。</p>
<p>SQL HAVING 语法：</p>
<pre><code class="language-sql">SELECT column1, aggregate_function(column2) FROM table_name GROUP BY column1 HAVING condition;
</code></pre>
<p><strong>参数说明：</strong></p>
<ul>
<li><code>column1</code>：要检索的列。</li>
<li><code>aggregate_function(column2)</code>：一个聚合函数，例如SUM、COUNT、AVG等，应用于<code>column2</code>的值。</li>
<li><code>table_name</code>：要从中检索数据的表。</li>
<li><code>GROUP BY column1</code>：根据<code>column1</code>列的值对数据进行分组。</li>
<li><code>HAVING condition</code>：一个条件，用于筛选分组的结果。只有满足条件的分组会包含在结果集中。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325145517.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150027.png" alt="" /></p>
<h2 id="706-用sql表达并交差操作7分20秒"><a class="header" href="#706-用sql表达并交差操作7分20秒">706-用SQL表达并交差操作(7分20秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150138.png" alt="" /></p>
<p>UNION运算符是Entry-SQL92的一部分</p>
<p>INTERSECT、EXCEPT运算符是Full-SQL92的一部分</p>
<p>它们都是Core-SQL99的一部分，但有些DBMS并不支持这些运算，使用时要注意</p>
<h2 id="707-用sql处理空值3分53秒"><a class="header" href="#707-用sql处理空值3分53秒">707-用SQL处理空值(3分53秒)</a></h2>
<p>空值是其值不知道、不确定、不存在的值</p>
<p>数据库中有了空值，会影响许多方面，如影响聚集函数运算的正确性，不能参与算术、比较或逻辑运算等</p>
<p>例如：右下图所示表SC，如果有某一记录为空值，则求001号课程的平均成绩？会是多少呢？</p>
<p>以前，很多DBMS将空值按默认值处理，如字符串类型则以空格来表示，而如数值类型则以0来表示，这也将会引起统计、计算上的不正确性。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150440.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150519.png" alt="" /></p>
<h2 id="708-用sql表达连接与外连接操作5分35秒"><a class="header" href="#708-用sql表达连接与外连接操作5分35秒">708-用SQL表达连接与外连接操作(5分35秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150550.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150613.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150655.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150840.png" alt="" /></p>
<h2 id="709-sql-select小结4分28秒"><a class="header" href="#709-sql-select小结4分28秒">709-SQL-SELECT小结(4分28秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325151207.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325151224.png" alt="" /></p>
<p>面向对象/对象关系数据库的查询SQL→OQL</p>
<p>基本的SQL：另一SELECT-FROM-WHERE只能出现在WHERE子句；</p>
<p>新标准：引入对象概念，可以在能使用聚集（collection）的任何位置使用SELECT-FROM-WEHRE</p>
<p>FROM子句中使用</p>
<p>SELECT子句中使用</p>
<p>Where子句中使用</p>
<p>注意：本课程要求基本的 SQL</p>
<h2 id="710-sql视图14分17秒"><a class="header" href="#710-sql视图14分17秒">710-SQL视图(14分17秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325151505.png" alt="" /></p>
<p>SQL数据库结构</p>
<ul>
<li>基本表是实际存储于存储文件中的表，基本表中的数据是需要存储的</li>
<li>视图在SQL中只存储其由基本表导出视图所需要的公式，即由基本表产生视图的映像信息，不存储其数据，而是在运行过程中动态产生与维护</li>
<li>对视图数据的更改最终要反映在对基本表的更改上</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325151656.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325151726.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325151800.png" alt="" /></p>
<p>可更新的视图是指可以对其进行插入、更新、删除操作的视图，这种视图通常基于单一表或多个表的简单查询结果构建而成，例如只包含一张表或者包含多张表但是通过 join 操作将其连接在一起的视图。在对可更新的视图进行操作时，系统会自动反映到视图所基于的表上。</p>
<p>不可更新的视图是指不能对其进行插入、更新、删除操作的视图，这种视图通常基于复杂的查询结果或包含特定计算、聚合、分组等操作的结果。例如，包含 group by 子句、distinct 子句、计算列、集合运算等的视图通常是不可更新的。在对不可更新的视图进行操作时，系统会提示更新失败或抛出错误信息。</p>
<p>总的来说，可更新的视图一般是简单的、基于单表或多表的连接查询，而不可更新的视图一般是复杂的、包含特定操作或计算结果的查询。</p>
<p>已经定义的视图也可以撤消</p>
<p>撤消视图</p>
<p><code>Drop View Viewname</code></p>
<p>当某一视图删除后，由该视图导出的其它视图也将自动删除</p>
<p>不仅视图可以撤消，基本表、数据库等都可以撤消</p>
<p>撤消基本表</p>
<p><code>Drop Table 表名</code></p>
<h2 id="第7讲模拟练习题"><a class="header" href="#第7讲模拟练习题">第7讲模拟练习题</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240325150138.png" alt="" /></p>
<p>这个问题需要理解SQL中的集合运算符（如EXCEPT，UNION，INTERSECT）的工作方式。下面是对四个选项的解释：</p>
<p>“子查询1 Except 子查询2”返回在子查询1中出现但不在子查询2中出现的元组。</p>
<p>“子查询1 Union 子查询2”返回在子查询1和子查询2中出现的所有元组，但重复的元组只会出现一次。</p>
<p>“子查询1 Except ALL 子查询2”返回在子查询1中出现但不在子查询2中出现的元组，但是这个运算会考虑重复的元组。</p>
<p>“子查询1 Intersect 子查询2”返回同时在子查询1和子查询2中出现的元组。</p>
<p>31<strong>假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0, 则下列说法正确的是____ ____。</strong></p>
<ul>
<li>
<p>A.该元组在“子查询1  Except  子查询2”中出现0次；</p>
</li>
<li>
<p>B.该元组在“子查询1  Union  子查询2”中出现m + n次；</p>
</li>
<li>
<p>C.该元组在 “子查询1  Except  ALL  子查询2”中出现m – n次；</p>
</li>
<li>
<p>D.该元组在“子查询1  Intersect  子查询2”中出现min(m,n)次；</p>
</li>
</ul>
<p>正确答案：A你错选为D</p>
<p>A.（正确答案）解析：Except是集合操作，出现0次</p>
<p>B.（错误答案）解析：此选项不正确。Union是集合操作，需去掉重复的元组</p>
<p>C.（错误答案）解析：此选项不正确。ExceptALL是包的操作，但应出现max（0，m-n）</p>
<p>D.（错误答案）解析：此选项不正确。Intersect是集合运算，只能出现一次。</p>
<p>32<strong>假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0,则下列说法正确的是_________。</strong></p>
<ul>
<li>
<p>A.该元组在“子查询1  Union  ALL 子查询2”中出现m + n次；</p>
</li>
<li>
<p>B.该元组在 “子查询1 Union  子查询2”中出现m+n次；</p>
</li>
<li>
<p>C.该元组在“子查询1  Union  ALL 子查询2”中出现1次；</p>
</li>
<li>
<p>D.该元组在 “子查询1 Union  子查询2”中出现min(m,n)次；</p>
</li>
</ul>
<p>正确答案：A你选对了</p>
<p>A.（正确答案）解析：此选项正确。UnionALL是包的操作，应出现m+n次</p>
<p>B.（错误答案）解析：此选项不正确。Union是集合的操作，应去掉重复的元组</p>
<p>C.（错误答案）解析：此选项不正确。UnionALL是包的操作，不应去掉重复的元组</p>
<p>D.（错误答案）解析：此选项不正确。Union是集合的操作，只能出现一次</p>
<p>33<strong>假设一个元组在子查询1中出现m次，在子查询2中出现n次，其中m&gt;0,n&gt;0,则下列说法正确的是_________。</strong></p>
<ul>
<li>
<p>A.该元组在“子查询1  Except  子查询2”中出现0次；</p>
</li>
<li>
<p>B.该元组在“子查询1  Union  子查询2”中出现m + n次；</p>
</li>
<li>
<p>C.该元组在 “子查询1  Except All 子查询2”中出现m – n次；</p>
</li>
<li>
<p>D.该元组在“子查询1  Union All  子查询2”中出现max(m,n)次；</p>
</li>
</ul>
<p>正确答案：A你错选为B</p>
<p>A.（正确答案）解析：此选项正确</p>
<p>B.（错误答案）解析：此选项不正确。Union是集合操作，只能出现一次</p>
<p>C.（错误答案）解析：此选项不正确。ExceptALL是包的操作，可出现<code>max(0, m-n)</code>次</p>
<p>D.（错误答案）解析：此选项不正确。UnionALL是包操作，出现m+n次。</p>
<p>40<strong>有一个学生表student，包含主键S#（学生编号）等。又有分数表SC，包含S#（学生编号）、score（分数）等。已知student表中共有50个学生，有45人参加了考试（分数存在SC表中），其中10人不及格。执行以下SQL语句：select * from student where exists (select S# from SC where score&lt;60 )， 可返回多少条记录？</strong></p>
<p>A.（正确答案）解析：此选项正确。因为这是非相关子查询，而且子查询始终为真（因为已
知有10人不及格），故检索出的是Student表中的所有记录</p>
<p>该SQL语句的结构使用了子查询和EXISTS关键字，这是一个半连接查询。它的意义是：如果子查询（select S# from SC where score&lt;60）返回的结果集不为空，那么主查询就会执行。这里的子查询是查找SC表中分数小于60的学生编号，根据题目，有10名学生不及格，所以子查询的结果集肯定不为空。</p>
<p><strong>然而，这个SQL语句的问题是，子查询并未与主查询产生直接的关联。即，主查询并不会因为子查询返回的S#而过滤结果。当EXISTS子查询返回真（即，存在至少一个满足条件的记录时），主查询就会返回所有记录</strong>。</p>
<p>所以，执行这个SQL语句将返回student表中所有的记录，即返回<strong>50条记录</strong>。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第8讲-sql语言与数据库完整性和安全性"><a class="header" href="#第8讲-sql语言与数据库完整性和安全性">第8讲-SQL语言与数据库完整性和安全性</a></h1>
<h2 id="800-本讲学习什么1分04秒及第8讲教学课件pdf"><a class="header" href="#800-本讲学习什么1分04秒及第8讲教学课件pdf">800-本讲学习什么（1分04秒）及第8讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326143516.png" alt="" /></p>
<h2 id="801-数据库完整性概念及完整性约束规则8分59秒"><a class="header" href="#801-数据库完整性概念及完整性约束规则8分59秒">801-数据库完整性概念及完整性约束规则(8分59秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326143552.png" alt="" /></p>
<p>为什么会引发数据库完整性的问题呢？</p>
<ul>
<li>不正当的数据库操作，如输入错误、操作失误、程序处理失误等</li>
</ul>
<p>数据库完整性管理的作用</p>
<ul>
<li>防止和避免数据库中不合理数据的出现</li>
<li>DBMS应尽可能地自动防止DB中语义不合理现象</li>
<li>如DBMS不能自动防止，则需要应用程序员和用户在进行数据库操作时处处加以小心，每写一条SQL语句都要考虑是否符合语义完整性，这种工作负担是非常沉重的，因此应尽可能多地让DBMS来承担</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326143842.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326143905.png" alt="" /></p>
<h2 id="802-数据库完整性分类4分16秒"><a class="header" href="#802-数据库完整性分类4分16秒">802-数据库完整性分类(4分16秒)</a></h2>
<p>一、按约束对象分类</p>
<p>域完整性约束条件：施加于某一列上，对给定列上所要更新的某一候选值是否可以接受进行约束条件判断，这是孤立进行的</p>
<p>关系完整性约束条件：施加于关系/table上，对给定table上所要更新的某一候选元组是否可以接受进行约束条件判断，或是对一个关系中的若干元组和另一个关系中的若干元组间的联系是否可以接受进行约束条件判断</p>
<p>二、按约束来源分类</p>
<p>结构约束：来自模型的约束，例如函数依赖约束、主键约束（实体完整性）、外键约束（参照完整性），只关心数值相等与否、是否允许空值等；</p>
<p>内容约束：来自用户的约束，如用户自定义完整性，关心元组或属性的取值范围。例如Student表的Sage属性值在15岁至40岁之间等</p>
<p>三、按约束状态分类</p>
<p>静态约束：要求DB在任一时候均应满足的约束；例如Sage在任何时候都应满足大于0而小于150（假定人活最大年龄是150）。</p>
<p>动态约束：要求DB从一状态变为另一状态时应满足的约束；例如工资只能升，不能降：工资可以是800元，也可以是1000元；可以从800元更改为1000元，但不能从1000元更改为800元</p>
<h2 id="803-sql表完整性与列完整性21分11秒"><a class="header" href="#803-sql表完整性与列完整性21分11秒">803-SQL表完整性与列完整性(21分11秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326144513.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326144533.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326144601.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326144628.png" alt="" /></p>
<p><strong>check中的条件可以是Select-From-Where内任何Where后的语句，包含子查询。</strong></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326144802.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326144833.png" alt="" /></p>
<h2 id="804-sql的断言及其应用4分50秒"><a class="header" href="#804-sql的断言及其应用4分50秒">804-SQL的断言及其应用(4分50秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326144854.png" alt="" /></p>
<h2 id="805-sql的触发器的概念6分34秒"><a class="header" href="#805-sql的触发器的概念6分34秒">805-SQL的触发器的概念(6分34秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326152429.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326152501.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326152521.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326152545.png" alt="" /></p>
<h2 id="806-触发器应用示例之一7分32秒"><a class="header" href="#806-触发器应用示例之一7分32秒">806-触发器应用示例之一(7分32秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326152613.png" alt="" /></p>
<h2 id="807-触发器应用示例之二5分29秒"><a class="header" href="#807-触发器应用示例之二5分29秒">807-触发器应用示例之二(5分29秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326152652.png" alt="" /></p>
<h2 id="808-第8讲回顾本讲学习了什么-完整性回顾1分51秒"><a class="header" href="#808-第8讲回顾本讲学习了什么-完整性回顾1分51秒">808-第8讲回顾本讲学习了什么-完整性回顾(1分51秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326152711.png" alt="" /></p>
<h2 id="809-数据库安全性的概念6分06秒"><a class="header" href="#809-数据库安全性的概念6分06秒">809-数据库安全性的概念(6分06秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220018.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220055.png" alt="" /></p>
<p>DBA的责任和义务</p>
<ul>
<li>熟悉相关的法规、政策，协助组织的决策者制定好相关的安全策略</li>
<li>规划好安全控制保障措施，例如，系统安全级别、不同级别上的安全控制措施，对安全遭破坏的响应,</li>
<li><strong>划分好数据的安全级别以及用户的安全级别</strong></li>
<li>实施安全性控制：DBMS专门提供一个DBA账户，该账户是一个超级用户或称系统用户。DBA利用该账户的特权可以进行用户账户的创建以及权限授予和撤消、安全级别控制调整等</li>
</ul>
<h2 id="810-自主安全性机制10分55秒"><a class="header" href="#810-自主安全性机制10分55秒">810-自主安全性机制(10分55秒)</a></h2>
<p>自主安全性机制</p>
<ul>
<li>通常情况下，自主安全性是通过授权机制来实现的。</li>
<li>用户在使用数据库前必须由DBA处获得一个账户，并由DBA授予该账户一定的权限，该账户的用户依据其所拥有的权限对数据库进行操作；同时，该帐户用户也可将其所拥有的权利转授给其他的用户(账户)，由此实现权限在用户之间的传播和控制。</li>
</ul>
<p>授权者：决定用户权利的人</p>
<p>授权：授予用户访问的权利</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220425.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220456.png" alt="" /></p>
<h2 id="811-两种自主安全性控制5分22秒"><a class="header" href="#811-两种自主安全性控制5分22秒">811-两种自主安全性控制(5分22秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220527.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220550.png" alt="" /></p>
<h2 id="812-sql安全性控制6分44秒"><a class="header" href="#812-sql安全性控制6分44秒">812-SQL安全性控制(6分44秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220618.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220702.png" alt="" /></p>
<p>授予视图访问的权利，并不意味着授予基本表访问的权利(两个级别：基本关系级别和视图级别）</p>
<p>授权者授予的权利必须是授权者已经拥有的权利</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220804.png" alt="" /></p>
<h2 id="813-自主安全性控制的问题3分56秒"><a class="header" href="#813-自主安全性控制的问题3分56秒">813-自主安全性控制的问题(3分56秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220832.png" alt="" /></p>
<h2 id="814-强制安全性机制4分51秒"><a class="header" href="#814-强制安全性机制4分51秒">814-强制安全性机制(4分51秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220900.png" alt="" /></p>
<p>DBMS引入强制安全性机制,可以通过扩展关系模式来实现</p>
<p>关系模式: R(A1: D1, A2: D2, ..., An:Dn)</p>
<p>对属性和元组引入安全性分级特性或称分类特性</p>
<p>R(A1: D1, C1, A2: D2, C2..., An:Dn, Cn, TC)</p>
<p>其中 C1,C2,..,Cn分别为属性D1,D2,..,Dn的安全分类特性; TC为元组的分类特性</p>
<p>这样,关系中的每个元组，都将扩展为带有安全分级的元组</p>
<p>强制安全性机制使得关系形成为多级关系(不同级别用户所能看到的关系的子集)，也出现多重实例、多级关系完整性等许多新的问题或新的处理技巧,在使用中需注意仔细研究。</p>
<h2 id="815-第8讲回顾本讲学习了什么-安全性回顾1分56秒"><a class="header" href="#815-第8讲回顾本讲学习了什么-安全性回顾1分56秒">815-第8讲回顾本讲学习了什么-安全性回顾(1分56秒)</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240326220942.png" alt="" /></p>
<h2 id="第8讲模拟练习题"><a class="header" href="#第8讲模拟练习题">第8讲模拟练习题</a></h2>
<p>在数据库的安全性控制中，授权的数据对象的范围越小，授权子系统就越灵活。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第9讲-嵌入式sql语言之基本技巧"><a class="header" href="#第9讲-嵌入式sql语言之基本技巧">第9讲-嵌入式SQL语言之基本技巧</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190538.png" alt="" /></p>
<h2 id="900-本讲学习什么1分47秒及第9讲教学课件pdf"><a class="header" href="#900-本讲学习什么1分47秒及第9讲教学课件pdf">900-本讲学习什么（1分47秒）及第9讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407184740.png" alt="" /></p>
<h2 id="901-什么是嵌入式sql语言10分20秒"><a class="header" href="#901-什么是嵌入式sql语言10分20秒">901-什么是嵌入式SQL语言（10分20秒）</a></h2>
<p>因此，高级语言+SQL语言：</p>
<p>既继承高级语言的过程控制性又结合SQL语言的复杂结果集操作的非过程性，同时又为数据库操作者提供安全可靠的操作方式：通过应用程序进行操作。</p>
<p>嵌入式SQL语言：</p>
<p>将SQL语言嵌入到某一种高级语言中使用。</p>
<p>这种高级语言，如C/C++，Java，PowerBuilder等，又称宿主语言（Host Language）</p>
<p>嵌入在宿主语言中的SQL与前面介绍的交互式SQL有一些不同的操作方式</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185058.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185116.png" alt="" /></p>
<h2 id="902-程序与数据库连接6分35秒"><a class="header" href="#902-程序与数据库连接6分35秒">902-程序与数据库连接（6分35秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185241.png" alt="" /></p>
<h2 id="903-为什么需要提交和撤销7分54秒"><a class="header" href="#903-为什么需要提交和撤销7分54秒">903-为什么需要提交和撤销（7分54秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185400.png" alt="" /></p>
<h2 id="904-嵌入式sql程序的一个示例5分50秒"><a class="header" href="#904-嵌入式sql程序的一个示例5分50秒">904-嵌入式SQL程序的一个示例（5分50秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185513.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185537.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185554.png" alt="" /></p>
<h2 id="905-为什么需要游标5分41秒"><a class="header" href="#905-为什么需要游标5分41秒">905-为什么需要游标（5分41秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185735.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185656.png" alt="" /></p>
<p>游标是指向某检索记录集的指针</p>
<p>通过这个指针的移动，每次读一行，处理一行，再读一行...，直至处理完毕</p>
<p>游标（Cursor）的使用需要先定义、再打开（执行）、接着一条接一条处理，最后再关闭</p>
<h2 id="906-游标应用示例9分13秒"><a class="header" href="#906-游标应用示例9分13秒">906-游标应用示例（9分13秒）</a></h2>
<h2 id="907-可滚动游标4分22秒"><a class="header" href="#907-可滚动游标4分22秒">907-可滚动游标（4分22秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407185932.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190018.png" alt="" /></p>
<p>可滚动游标移动时需判断是否到结束位置，或到起始位置</p>
<ul>
<li>可通过判断是否到EOF位置（最后一条记录的后面），或BOF位置（起始记录的前面）</li>
<li>如果不需区分，可通过whenever not found语句设置来检测</li>
</ul>
<h2 id="908-利用游标进行数据库增删改3分32秒"><a class="header" href="#908-利用游标进行数据库增删改3分32秒">908-利用游标进行数据库增删改（3分32秒）</a></h2>
<h2 id="909-利用游标编写的一个程序3分42秒"><a class="header" href="#909-利用游标编写的一个程序3分42秒">909-利用游标编写的一个程序（3分42秒）</a></h2>
<h2 id="910-异常状态捕获机制14分26秒"><a class="header" href="#910-异常状态捕获机制14分26秒">910-异常状态捕获机制（14分26秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190222.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190244.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190301.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190324.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190352.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190434.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190457.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407190514.png" alt="" /></p>
<h2 id="第9讲模拟练习题"><a class="header" href="#第9讲模拟练习题">第9讲模拟练习题</a></h2>
<p>21执行下面的程序：</p>
<pre><code class="language-c">int main()

{   

	exec sql  whenever  sqlerror  goto  handle_error；
	
	exec sql  create table customers(cid  char(4)  not null, cname varchar(13), …)；
	
	…
	
	handle_error：
	
	exec sql drop customers；
	
	exec sql disconnect；
	
	fprintf(stderr,”could not create customers table\n”)；
	
	return -1；

}
</code></pre>
<p>如果customers表在执行过程中出现了问题，没有人为干预，则该程序“Exec sql drop customers；”语句将被执行的次数为无限。</p>
<p>解析：如果customers表在执行过程中出现问题，程序将跳转到handle_error标签并执行其中的代码。在handle_error标签中，程序会执行"exec sql drop customers"语句，然后再次跳转回handle_error标签。这样会导致无限循环执行该语句，因为每次执行后仍然会出现问题导致再次跳转到handle_error标签。所以，“exec sql drop customers；”语句将被执行的次数为无限次。</p>
<h2 id="附录-c-with-mysql"><a class="header" href="#附录-c-with-mysql">附录 C With MySQL</a></h2>
<p>当使用C语言和MySQL进行联合处理时，通常会使用MySQL提供的C API（MySQL C API）来与数据库进行交互。通过这个API，可以在C语言中执行查询、获取结果集、插入记录等操作。</p>
<p>下面是一个简单的示例代码，演示如何使用C语言和MySQL进行联合处理：</p>
<pre><code class="language-c">#include &lt;stdio.h&gt;
#include &lt;mysql/mysql.h&gt;

int main() {
    MYSQL *conn;
    MYSQL_RES *res;
    MYSQL_ROW row;

    conn = mysql_init(NULL);
    if (conn == NULL) {
        fprintf(stderr, "mysql_init() failed\n");
        return 1;
    }

    if (mysql_real_connect(conn, "localhost", "user", "password", "database", 0, NULL, 0) == NULL) {
        fprintf(stderr, "mysql_real_connect() failed\n");
        mysql_close(conn);
        return 1;
    }

    if (mysql_query(conn, "SELECT * FROM table")) {
        fprintf(stderr, "mysql_query() failed\n");
        mysql_close(conn);
        return 1;
    }

    res = mysql_store_result(conn);
    if (res == NULL) {
        fprintf(stderr, "mysql_store_result() failed\n");
        mysql_close(conn);
        return 1;
    }

    while ((row = mysql_fetch_row(res))) {
        printf("%s\n", row[0]);
    }

    mysql_free_result(res);
    mysql_close(conn);

    return 0;
}
</code></pre>
<p>在上面的代码中，我们首先初始化了一个MySQL连接，然后连接到指定的数据库，执行了一个SELECT查询，并打印查询结果中的第一列数据。</p>
<p>关于MySQL C API的更多信息和文档，你可以参考MySQL官方网站：<a href="https://dev.mysql.com/doc/c-api/en/%E3%80%82">https://dev.mysql.com/doc/c-api/en/。</a></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第10讲-嵌入式sql语言之动态sql"><a class="header" href="#第10讲-嵌入式sql语言之动态sql">第10讲-嵌入式SQL语言之动态SQL</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406145048.png" alt="" /></p>
<h2 id="a00-本讲学习什么1分15秒及第10讲教学课件pdf"><a class="header" href="#a00-本讲学习什么1分15秒及第10讲教学课件pdf">A00-本讲学习什么（1分15秒）及第10讲教学课件PDF</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406142136.png" alt="" /></p>
<h2 id="a01-动态sql的概念和作用7分37秒"><a class="header" href="#a01-动态sql的概念和作用7分37秒">A01-动态SQL的概念和作用（7分37秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406142330.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406142346.png" alt="" /></p>
<h2 id="a02-动态sql构造示例之一15分41秒"><a class="header" href="#a02-动态sql构造示例之一15分41秒">A02-动态SQL构造示例之一（15分41秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406142458.png" alt="" /></p>
<h2 id="a03-动态sql构造示例之二16分17秒"><a class="header" href="#a03-动态sql构造示例之二16分17秒">A03-动态SQL构造示例之二（16分17秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406142533.png" alt="" /></p>
<h2 id="a04-动态sql的两种执行方式5分44秒"><a class="header" href="#a04-动态sql的两种执行方式5分44秒">A04-动态SQL的两种执行方式（5分44秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406142639.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406142823.png" alt="" /></p>
<h2 id="a05-数据字典及其作用14分05秒"><a class="header" href="#a05-数据字典及其作用14分05秒">A05-数据字典及其作用（14分05秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406143037.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406143102.png" alt="" /></p>
<p>模式的含义是指某一用户所设计和使用的表、索引及其他与数据库有关的对象的集
合，因此表的完整名应是：模式名.表名。这样做可允许不同用户使用相同的表名，而
不混淆。</p>
<p>一般而言，一个用户有一个模式。可以使用 Create schema 语句来创建模式（用法
略，参见相关文献），在 Create Table 等语句可以使用所定义的模式名称。</p>
<h2 id="a06-sqlda与数据字典的应用5分33秒"><a class="header" href="#a06-sqlda与数据字典的应用5分33秒">A06-SQLDA与数据字典的应用（5分33秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406143433.png" alt="" /></p>
<h2 id="a07-什么是odbc10分21秒"><a class="header" href="#a07-什么是odbc10分21秒">A07-什么是ODBC（10分21秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406143605.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406143851.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406144044.png" alt="" /></p>
<h2 id="a08-什么是jdbc9分31秒"><a class="header" href="#a08-什么是jdbc9分31秒">A08-什么是JDBC（9分31秒）</a></h2>
<p>JDBC是什么？</p>
<p>JDBC:Java DataBase Connection</p>
<p>JDBC是一组Java版的应用程序接口API，提供了Java应用程序与数据库服务器的连接和通讯能力。</p>
<p>JDBC API</p>
<p>JDBC API分成两个程序包：</p>
<p>1、Java.sql 核心API--J2SE （Java2标准版）的一部分。使用java.sql.DriverManager类、java.sgl.Driver和Java.sql.connection接口连接到数据库</p>
<p>2、Javax.sql可选扩展API--J2EE（Java2企业版）的一部分。包含了基于JNDI（Java Naming and Directory Interface，Java命名和目录接口）的资源，以及管理连接池、分布式事务等，使用Datasource接口连接到数据库。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406144620.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406144717.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406144747.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406144852.png" alt="" /></p>
<h2 id="a09-odbc-jdbc-嵌入式之比较10分22秒"><a class="header" href="#a09-odbc-jdbc-嵌入式之比较10分22秒">A09-ODBC-JDBC-嵌入式之比较（10分22秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406144928.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406144953.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240406145012.png" alt="" /></p>
<h2 id="第10讲模拟练习题"><a class="header" href="#第10讲模拟练习题">第10讲模拟练习题</a></h2>
<p>5、应用程序使用JDBC API访问数据库的具体实施过程有4步：</p>
<p>(3) 传递一个Driver给DriverManager，加载数据库驱动；</p>
<p>(1) 通过URL得到一个Connection对象, 建立数据库连接；</p>
<p>(2) 创建一个Statement对象(PreparedStatement或CallableStatement)，用来查询或者修改数据库；</p>
<p>(4) 执行查询并返回一个ResultSet，提取数据到应用程序。</p>
<p>9、SQLCA和SQLDA是嵌入在C语言中的SQL语言经常使用的两种数据结构。关于SQLCA和SQLDA，下列说法正确的是_________。</p>
<p>SQLCA是SQL通讯区，记录着SQL语句被DBMS执行后返回的状态信息；SQLDA是SQL描述区，记录着数据库/表等对象的定义信息。</p>
<p>10、应用程序通过ODBC连接一个数据库服务器的基本步骤如下：</p>
<p>(2)   SQLAllocConnect(env, &amp;conn);</p>
<p>(1)   SQLConnect(conn, "aura.bell-labs.com", SQL_NTS, "avi", SQL_NTS, avipasswd", SQL_NTS);</p>
<p>(3)   { …. Do actual work … }</p>
<p>(4)   SQLDisconnect(conn)；SQLFreeConnect(conn)；SQLFreeEnv(env)；</p>
<p>11、关于嵌入式SQL语言的思维模式，说法正确的是_________。</p>
<p>建立数据库连接-&gt;声明一个游标(游标与SQL语句绑定)-&gt;打开游标(执行SQL语句)-&gt;循环地获取一条一条记录(属性与高级语言变量绑定)-&gt;关闭游标-&gt;可循环地再打开到关闭游标-&gt;断开数据库连接。</p>
<p>12、关于下面的思维模式，“建立数据库连接-&gt;请求分配语句句柄(申请内存空间)-&gt;用句柄执行SQL(句柄与SQL语句绑定)-&gt;建立高级语言变量与句柄属性的对应-&gt;循环地获取一条一条记录-&gt;释放语句句柄-&gt;断开数据库连接”。这是关于ODBC的思维模式。</p>
<p>13、关于下面的思维模式，“建立数据库连接-&gt;创建语句对象(申请内存空间)-&gt;用语句对象执行SQL(语句对象与SQL语句绑定)-&gt;返回结果对象-&gt;循环地从结果对象获取一条一条记录并提取对象的属性值传给高级语言变量-&gt;释放语句对象-&gt;断开数据库连接”。这是关于JDBC的思维模式。</p>
<p>14、SQL语句执行后，需要将结果记录集中的属性值，读到高级语言的变量中，那什么时候建立高级语言变量与属性的绑定，下列说法都正确。</p>
<p>嵌入式SQL语言：在一条一条地读取记录时(Fetch)建立绑定。</p>
<p>ODBC：在开始一条一条地读取记录之前用专门的语句建立绑定。</p>
<p>JDBC：一条一条记录的，边绑定，边读取相应的属性值。</p>
<p>16、一段构造SQL语句的程序代码如下：</p>
<pre><code class="language-c">char *dcid, *acid, *ecid； 

dcid = “001”； ecid= “002”； acid= “003”；

strcpy(sqltext， “SELECT  *  from  Student  where  s# =”);

strcpy(sqltext，“: dcid”);

… …

exec sql whenever not found goto no_such_s#;

    exec sql prepare  ecid  from :sqltext;     

    exec sql execute  ecid  using :acid;    

    exec sql commit work;  continue;

 no_such_s#: printf("No such student in table Student\n");

    continue;
</code></pre>
<p>问：当该段程序执行“exec sql execute  ecid  using :acid;”语句时，其执行的查询是_______。</p>
<ul>
<li>
<p>A.检索001号同学的信息</p>
</li>
<li>
<p>B.检索002号同学的信息</p>
</li>
<li>
<p>C.检索003号同学的信息</p>
</li>
<li>
<p>D.其他都不是</p>
</li>
</ul>
<p>正确答案：C你错选为A</p>
<p>正确答案：C。解析：真正传给动态SOL语句的变量是acid，即检索003号同学的信息</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第1讲总第11讲数据建模思想与方法暨数据库设计之抽象与表达方法"><a class="header" href="#第1讲总第11讲数据建模思想与方法暨数据库设计之抽象与表达方法">第1讲（总第11讲）数据建模：思想与方法(暨数据库设计之抽象与表达方法)</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329154405.png" alt="" /></p>
<h2 id="1100-本讲学习什么4分33秒及第11讲教学课件"><a class="header" href="#1100-本讲学习什么4分33秒及第11讲教学课件">1100-本讲学习什么（4分33秒）及第11讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329133101.png" alt="" /></p>
<p>“数据建模与数据库设计”内容学习的目标？</p>
<ul>
<li>理解数据建模与数据库设计</li>
<li>扎实地理解并掌握E-R模型/IDEF1X模型：数据建模与数据库设计的重要工具</li>
</ul>
<p>能够绘制E-R图/IDEF1X图而且绘制得正确</p>
<ul>
<li>能够用E-R/IDEF1X模型准确理解现实世界并进行数据库设计</li>
</ul>
<p>理解现实世界并进行抽象的能力，理解并抽象得正确</p>
<ul>
<li>能够分析数据库设计的正确性</li>
</ul>
<h2 id="1101-为什么要数据建模与数据库设计5分21秒"><a class="header" href="#1101-为什么要数据建模与数据库设计5分21秒">1101-为什么要数据建模与数据库设计（5分21秒）</a></h2>
<p>需求的理解，简单来讲，包括数据需求的理解和处理规则需求的理解.....</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329133637.png" alt="" /></p>
<h2 id="1102-数据模型与概念模型的概念4分44秒"><a class="header" href="#1102-数据模型与概念模型的概念4分44秒">1102-数据模型与概念模型的概念（4分44秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329133537.png" alt="" /></p>
<h2 id="1103-关于抽象的八个字2分10秒"><a class="header" href="#1103-关于抽象的八个字2分10秒">1103-关于抽象的八个字（2分10秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329133213.png" alt="" /></p>
<h2 id="1104-什么是e-r模型2分21秒"><a class="header" href="#1104-什么是e-r模型2分21秒">1104-什么是E-R模型（2分21秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329133901.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329133926.png" alt="" /></p>
<h2 id="1105-实体与实例6分48秒"><a class="header" href="#1105-实体与实例6分48秒">1105-实体与实例（6分48秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329140153.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329140216.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329140239.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329140302.png" alt="" /></p>
<h2 id="1106-联系与联系的元数4分39秒"><a class="header" href="#1106-联系与联系的元数4分39秒">1106-联系与联系的元数（4分39秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329140339.png" alt="" /></p>
<p>参与发生联系的实体的数目，称为联系的度或元</p>
<p>联系有一元联系、二元联系和多元联系</p>
<p>联系是需要存储和处理的</p>
<p>实体是相对稳定的，但是联系是多样化的</p>
<p>一元联系：同一个实体中的实例之间的联系</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329140934.png" alt="" /></p>
<h2 id="1107-联系与联系的基数6分29秒"><a class="header" href="#1107-联系与联系的基数6分29秒">1107-联系与联系的基数（6分29秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329141015.png" alt="" /></p>
<p>联系的基数（Cardinalities）：实体实例之间的联系的数量，即一个实体的实例通过一个联系能与另一实体中相关联的实例的数目</p>
<p>常见的映射基数如上，有一对一的（1:1），一对多的（1:m），多对多的（m:n）几种情况</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329141633.png" alt="" /></p>
<h2 id="1108-chen方法表达e-r模型12分49秒"><a class="header" href="#1108-chen方法表达e-r模型12分49秒">1108-Chen方法表达E-R模型（12分49秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329141807.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329143708.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329143804.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329143842.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329143928.png" alt="" /></p>
<h2 id="1109-chen方法建模案例-物资管理系统数据建模8分20秒"><a class="header" href="#1109-chen方法建模案例-物资管理系统数据建模8分20秒">1109-Chen方法建模案例-物资管理系统数据建模（8分20秒）</a></h2>
<p>Step1理解需求，寻找实体</p>
<p>E-R图建模首先要找出问题领域的实体，即找出有哪些类/实体</p>
<p>能够用一个个、一件件、一串串等重叠量词形容的，而不是一个、一件...</p>
<p>要覆盖需求涉及的可独立管理的每一类事物</p>
<p>Step2用属性刻画每一个实体，至少要给出一个重要属性</p>
<p>Step3确定每一个实体的关键字/码，关键字属性是必须要标记清晰的</p>
<p>Step4数据建模的重点是分析实体之间的联系</p>
<p>Step5检查是否覆盖了需求</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329144927.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329144946.png" alt="" /></p>
<h2 id="1110-crows-foot方法表达e-r模型8分40秒"><a class="header" href="#1110-crows-foot方法表达e-r模型8分40秒">1110-Crow's Foot方法表达E-R模型（8分40秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329145250.png" alt="" /></p>
<p>联系：菱形框表示，也可以将菱形框省略而直接以联系名来替代</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329145345.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329145421.png" alt="" /></p>
<h2 id="1111-crows-foot方法建模案例-物资管理系统数据建模4分55秒"><a class="header" href="#1111-crows-foot方法建模案例-物资管理系统数据建模4分55秒">1111-Crow's Foot方法建模案例-物资管理系统数据建模（4分55秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329145516.png" alt="" /></p>
<h2 id="1112-型与值和三个世界7分54秒"><a class="header" href="#1112-型与值和三个世界7分54秒">1112-型与值和三个世界（7分54秒）</a></h2>
<p>信息</p>
<ul>
<li>信息是现实世界中事物在人们头脑中的一种反映</li>
<li>信息可以准确地反映现实世界中事物（描述）</li>
<li>也可以通过对现实进行抽象，形成信息（抽象）</li>
</ul>
<p>数据库设计往往因为忽视了信息（之间联系）的细致分析而造成设计失误</p>
<p>数据库设计能力的高低往住体现在信息（及其联系）的正确分析上，体现在理解现实世界能力的高低</p>
<p>三个世界与多层（级）抽象</p>
<p>现实世界==&gt;（描述、抽象为）信息世界==&gt;（描述、抽象为）计算机世界</p>
<p>现实（客观存在）==&gt;抽象/描述（概念/观念）==&gt;计算机中（用计算机实现）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329151759.png" alt="" /></p>
<p>类似的概念：</p>
<ul>
<li>“型”（Type）与值（Value）</li>
<li>”模式（Schema）与“数据（Data）“</li>
<li>“数据模型（DataModel）“与“模式（Schema）”</li>
<li>”模式（Schema）”与“实例（Instance）”</li>
<li>“类（Class）”与”对象（Object）“</li>
<li>”实体（Entity）”与“实例（Instance）”</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329152032.png" alt="" /></p>
<h2 id="1113-数据模型与两种抽象层次8分06秒"><a class="header" href="#1113-数据模型与两种抽象层次8分06秒">1113-数据模型与两种抽象层次（8分06秒）</a></h2>
<p>数据模型</p>
<ul>
<li>不同范围的人对现实世界中事物的描述和抽象可能是不同的</li>
<li>现实的抽象与描述需要遵循统一的数据模型：统一的概念与统一的表达方法</li>
<li>数据模型是一组相互关联且已严格定义的概态集合，是用于刻画或描述现实世界、信息世界或计算机世界的模型</li>
<li>用统一的模型建模也是计算机学科学生所无为擅长的能力</li>
</ul>
<p>统一是为了信息交流、信息共享</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329133537.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329154214.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329154239.png" alt="" /></p>
<h2 id="1114-再看抽象层次6分39秒"><a class="header" href="#1114-再看抽象层次6分39秒">1114-再看抽象层次（6分39秒）</a></h2>
<p>建模的不同层次：模型与元模型，模型（型）与实例（值）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240329154338.png" alt="" /></p>
<h2 id="第1讲总第11讲模拟题"><a class="header" href="#第1讲总第11讲模拟题">第1讲（总第11讲）模拟题</a></h2>
<p>实体虽然是指一个个可相互区分的个体，但E-R图建模是要寻找这些个体的“型”，而非这些个体本身；</p>
<p>实体是可以用重叠量词来形容的，在问题域中不能用重叠量词形容的则不是实体；</p>
<p>联系是指一个实体的实例与另一个实体的实例之间可能存在的某种联系；</p>
<p>在发现联系的过程中重点是联系的基数的判定即一个实体实例能够和另外实体的多少个实例发生联系，因为这将影响数据库设计——如何处理联系。</p>
<p>参与发生联系的实体的数目，称为联系的度或元。联系有一元联系、二元联系和多元联系</p>
<p>模型是依据元模型中的抽象概念及其关系，对现实世界进行理解，获得具体概念及其具体关系所形成的；</p>
<p>元模型是对模型的抽象，而模型是对现实世界的抽象；</p>
<p>同一元模型，可以产生不同的模型；而同一现实世界，也可以产生不同的模型。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第12讲-数据建模工程化方法及案例分析"><a class="header" href="#第12讲-数据建模工程化方法及案例分析">第12讲-数据建模：工程化方法及案例分析</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330151214.png" alt="" /></p>
<h2 id="1200-本讲学习什么36秒及第12讲教学课件"><a class="header" href="#1200-本讲学习什么36秒及第12讲教学课件">1200-本讲学习什么（36秒）及第12讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330131718.png" alt="" /></p>
<h2 id="1201-什么是idef1x3分21秒"><a class="header" href="#1201-什么是idef1x3分21秒">1201-什么是IDEF1X（3分21秒）</a></h2>
<p>IDEF1x是将E-R模型扩充语义含义而形成的，或者说，IDEF1x是E-R图的细化。</p>
<p>IDEF1x是一种进行数据建模或数据库设计的工程化的方法</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330131836.png" alt="" /></p>
<h2 id="1202-独立实体和从属实体10分24秒"><a class="header" href="#1202-独立实体和从属实体10分24秒">1202-独立实体和从属实体（10分24秒）</a></h2>
<p>实体（Entity）：一个“实体”表示一个现实和抽象事物的集合，这些事物必须具有相同的属性和特征。这个集合的一个元素就是该实体的一个实例。</p>
<p>实体被区分为独立实体和从属实体；在扩展E-R图中，独立实体又称强实体，从属实体又称弱实体。</p>
<p>独立实体：一个实体的实例都被唯一的标识而不决定于它与其他实体的联系</p>
<p>独立实体的关键字属性是自身拥有的属性</p>
<p>从属实体：一个实体的实例的唯一标识需要依赖于该实体与其他实体的联系</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330143500.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330143529.png" alt="" /></p>
<p>一些规则续：</p>
<ul>
<li>每一个实体必须使用唯一的实体名，相同的含义总是用于同一实体名，相同的含义不能用于不同的实体名</li>
<li>一个实体可以有一个或多个属性，这些属性可以是其自身所具有的，也可以是通过一个联系而继承得到的</li>
<li>一个实体应有一个或多个能唯一标识实体每一个实例的属性，即应有一个主关键字及若干次关键字（0或多个）</li>
<li>任意实体都可与模型中任意其他的实体有任何联系</li>
<li>如果一个完全外来关键字是一个实体主关键字的全部或部分，那么该实体就是从属实体。相反，如果仅一部分或根本没有外来关键字属性用作一个实体的主关键字，那么，这个实体就是独立实体</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330143825.png" alt="" /></p>
<p>关于属性的规则：工程化的要求</p>
<ul>
<li>每个属性都必须有一个唯一的名称，且相同的名字必须总是描述相同的含义。因此相同的含义不可能对应于不同的名字（别名除外）</li>
<li>每个实体可以具有任意个属性，一个属性只能归属于一个实体，这一规则称下“单主规则</li>
<li>一个实体可有任意个继承属性，而每个继承属性都必须是某个相关的父亲实体或一般实体主关键字的一部分。</li>
<li>实体的每一个实例，对每一个属性都必须具有一个值。这一规则称为“非空规则</li>
<li>就同某实体相关的属性而言，该实体没有一个实例可能具有一个以上的值。这一规则称为“非重复规则</li>
</ul>
<p>（5）关于属性和关键字</p>
<p>关于主关键字和次关键字的规则：工程化的要求</p>
<ul>
<li>每个实体必须有一个主关键字，可有任意个次关键字</li>
<li>主关键字和次关键字可由单个或多个属性组成</li>
<li>个别属性可以是多个关键字的一部分</li>
<li>构成主关键字或次关键字的属性可以是实体自身所具有的或由某些联系继承得到的属性</li>
<li>主关键字和次关键字必须仅包含有助于唯一标识实体的那些属性。也就是说，如果主关键字或次关键字中去掉任一部分属性，那么都无法唯一确定实体的实例。此规则称“最小关键字规则“</li>
<li>如主关键字是由多个属性组成，那么每个非键属性的值必须完全函数依赖于主关键字，也就是，如果主关键字的一部分属性被确定了，那么非键属性的值无法唯一确定。此规则称“完全函数依赖规则”</li>
<li>每个非键属性必须是仅仅函数依赖于主关键字和次关键字，也就是，没有一个非键属性的值能够由其他非键属性的值所确定。此规则称“非传递依赖规则“</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330144731.png" alt="" /></p>
<p>（6）关于外码-外来关键字</p>
<p>关于外来关键字的规则：工程化的要求</p>
<ul>
<li>在确定连接联系或分类联系中的儿子实体或分类实体时必须包含一个外来关键字</li>
<li>一般实体的主关键字必须遗传为每一个分类实体的主关键字</li>
<li>存在一个联系，只能有一个外来关键字</li>
<li>被继承属性只能是主关键字所包含的属性</li>
<li>分配给继承属性的每一个作用名（Role Name）都必须是唯一的，同时同一含义必须应用于同一作用名</li>
<li>如果在某实体的任一给定实例中，对于两个外来关键字而言，单一遗传属性总是具有相同值，那么，该属性可以是多个外来关键字的部分</li>
</ul>
<h2 id="1203-标定联系和非标定联系6分07秒"><a class="header" href="#1203-标定联系和非标定联系6分07秒">1203-标定联系和非标定联系（6分07秒）</a></h2>
<p>联系（Relationship）是实体之间的一种连接关系</p>
<p>联系有连接联系、分类联系和不确定性联系</p>
<p>连接联系，又称父子联系或依存联系，又可进一步区分为标定联系和非标定联系</p>
<p>联系分类：</p>
<ul>
<li>标定联系</li>
<li>非标定联系</li>
<li>分类联系</li>
<li>非确定联系</li>
</ul>
<p>IDEF1X建模重点在联系的识别与处理</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330153057.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330153135.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330153240.png" alt="" /></p>
<p>（4）一些规则</p>
<ul>
<li>一个确定性连接联系总是存在于两个实体之间，一个作为父实体，另一个作为子实体</li>
<li>子实体的一个实例必须且总是恰好地与父实体的一个实例相联系</li>
<li>父实体一个实例可与子实体的0个、1个或多个实例相联系，具体情况由特定基数而定。在子实体端标注P（1或大于1）/Z（0或1）/n（确定数目）/&lt;省略&gt;（0、1或大于1）</li>
<li>在标定联系中的子实体总是一个从属标识符实体</li>
<li>一个实体可以与任意多个其他实体相联系，可以在不同的联系中充当不同的角色，如在一些联系中充当父实体，而在另外一些联系中充当子实体。</li>
</ul>
<h2 id="1204-非确定联系与相交实体5分31秒"><a class="header" href="#1204-非确定联系与相交实体5分31秒">1204-非确定联系与相交实体（5分31秒）</a></h2>
<p>非确定联系：即实体之间的多对多的联系</p>
<p>非确定联系必须分解为若干个一对多的联系来表达</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330153549.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330153703.png" alt="" /></p>
<p>关于非确定联系的规则：工程化的要求</p>
<ul>
<li>一个非确定联系总是存在于两个实体之间，而不是三个或更多个实体之间</li>
<li>两个实体中，任意一个实体的实例可以与另一实体的0，1或多个实例相关联，具体情况要视情况而定，在图中标出其基数</li>
<li>为了完全地设计出一个模型，非确定联系必须由确定联系来替代</li>
</ul>
<h2 id="1205-分类联系与分类实体9分44秒"><a class="header" href="#1205-分类联系与分类实体9分44秒">1205-分类联系与分类实体（9分44秒）</a></h2>
<p>分类联系：一个实体实例是由一个一般实体实例及多个分类实体实例构成的</p>
<ul>
<li>一个一般实体是若干具体实体（分类实体）的类</li>
<li>分类实体与一般实体具有相同的主关键字</li>
<li>不同分类实体除具有一般实体特征外，各自还可能具有不同的属性特征</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330154006.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330154032.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330154054.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330154118.png" alt="" /></p>
<p>（3）泛化与具体化</p>
<p>属性继承</p>
<ul>
<li>高层实体的属性被低层实体自动继承</li>
<li>低层实体特有的性质仅适用于某个特定的低层实例</li>
<li>如”Dissertation属性只适用于“研究生”实例</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330154242.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240330154304.png" alt="" /></p>
<p>一些规则：</p>
<ul>
<li>一个分类实体只能有一个对应的一般实体，即对一分类联系而言，它只能是一个分类集的成员</li>
<li>一个分类联系中的一个分类实体可以是一个其他分类联系中的一般实体</li>
<li>一个实体可以具有任意个分类联系，在这些分类联系中，这个实体作为一般实体。例如“雇员”实体可分类为“计时雇员”和“月薪雇员”，也可分类为“普通雇员”和“高级雇员”</li>
<li>一个分类实体不能是可标定联系中的子实体</li>
<li>分类实体的主关键字属性必须和一股实体主关键字属性相同。</li>
<li>一个分类实体的全部实例都具有相同的“鉴别器值”，并且不同分类实体的实例都具有不同的鉴别器值</li>
</ul>
<h2 id="1206-idef1x案例讲解之一-四个建模小例子11分13秒"><a class="header" href="#1206-idef1x案例讲解之一-四个建模小例子11分13秒">1206-IDEF1X案例讲解之一-四个建模小例子（11分13秒）</a></h2>
<h2 id="1207-idef1x案例讲解之二-仓储系统建模8分47秒"><a class="header" href="#1207-idef1x案例讲解之二-仓储系统建模8分47秒">1207-IDEF1X案例讲解之二-仓储系统建模（8分47秒）</a></h2>
<h2 id="1208-idef1x案例讲解之三-物料系统建模7分21秒"><a class="header" href="#1208-idef1x案例讲解之三-物料系统建模7分21秒">1208-IDEF1X案例讲解之三-物料系统建模（7分21秒）</a></h2>
<h2 id="1209-idef1x案例讲解之四-六个模型示例点评14分21秒"><a class="header" href="#1209-idef1x案例讲解之四-六个模型示例点评14分21秒">1209-IDEF1X案例讲解之四-六个模型示例点评（14分21秒）</a></h2>
<h2 id="1210-idef1x案例讲解之五-联赛管理系统建模4分33秒"><a class="header" href="#1210-idef1x案例讲解之五-联赛管理系统建模4分33秒">1210-IDEF1X案例讲解之五-联赛管理系统建模（4分33秒）</a></h2>
<h2 id="第2讲总第12讲模拟题"><a class="header" href="#第2讲总第12讲模拟题">第2讲（总第12讲）模拟题</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240331154048.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第13讲-数据库设计过程"><a class="header" href="#第13讲-数据库设计过程">第13讲-数据库设计过程</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401190623.png" alt="" /></p>
<h2 id="1300-本讲学习什么3分51秒及第13讲教学课件"><a class="header" href="#1300-本讲学习什么3分51秒及第13讲教学课件">1300-本讲学习什么（3分51秒）及第13讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401184549.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401184636.png" alt="" /></p>
<h2 id="1301-如何做需求分析6分32秒"><a class="header" href="#1301-如何做需求分析6分32秒">1301-如何做需求分析（6分32秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401184858.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401184752.png" alt="" /></p>
<h2 id="1302-如何做概念数据库设计12分10秒"><a class="header" href="#1302-如何做概念数据库设计12分10秒">1302-如何做概念数据库设计（12分10秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401184938.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185235.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185315.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185338.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185405.png" alt="" /></p>
<h2 id="1303-如何做逻辑数据库设计17分43秒"><a class="header" href="#1303-如何做逻辑数据库设计17分43秒">1303-如何做逻辑数据库设计（17分43秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185429.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185504.png" alt="" /></p>
<p>基本转换规则：复合属性的转换</p>
<p>将每个分量属性作为复合属性所在实体的属性或者，将复合属性本身作为所在实体的属性</p>
<p>示例</p>
<p>学生（学号，姓名，年，月，日）或者学生（学号，出生日期，姓名）</p>
<p>基本转换规则：多值属性的转换</p>
<p>将多值属性与所在实体的关键字一起组成一个新的关系</p>
<p>示例</p>
<p>学生（学号，姓名）</p>
<p>选课（学号，所选课程号）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185756.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185820.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185839.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185903.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185929.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401185949.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401190041.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401190023.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401190116.png" alt="" /></p>
<h2 id="1304-逻辑数据库设计会出现什么问题7分54秒"><a class="header" href="#1304-逻辑数据库设计会出现什么问题7分54秒">1304-逻辑数据库设计会出现什么问题（7分54秒）</a></h2>
<p>不正确设计数据库引发的问题</p>
<p>冗余：数据库中存在大量冗余</p>
<p>非受控冗余</p>
<p>例如，右侧数据库设计</p>
<p>受控冗余问题</p>
<p>当数据发生改变时，如何使冗余数据同步更新？</p>
<p>如何避免？</p>
<p>设计满足规范性，由DBMS或数据库本身来保证</p>
<p>设计不满足规范性，由使用者或应用程序员使用过程中加以注意</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401190357.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401190419.png" alt="" /></p>
<h2 id="1305-如何做物理数据库设计3分33秒"><a class="header" href="#1305-如何做物理数据库设计3分33秒">1305-如何做物理数据库设计（3分33秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401190438.png" alt="" /></p>
<p>设计用户视图及访问控制规则，以进行安全性控制</p>
<p>建立索引</p>
<p>设计使数据库运行达到最佳效率的一些措施</p>
<p>设计备份Backup和恢复Recovery的步骤</p>
<p>理解Oracle、Sybase或其他DBMS的物理数据库管理方式，这是数据库管理员（DBA）的基本责任</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240401190605.png" alt="" /></p>
<h2 id="第3讲总第13讲模拟题"><a class="header" href="#第3讲总第13讲模拟题">第3讲（总第13讲）模拟题</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240331152552.png" alt="" /></p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第14讲-函数依赖及其公理定理"><a class="header" href="#第14讲-函数依赖及其公理定理">第14讲-函数依赖及其公理/定理</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404184425.png" alt="" /></p>
<h2 id="1400-本讲学习什么1分28秒及第14讲教学课件"><a class="header" href="#1400-本讲学习什么1分28秒及第14讲教学课件">1400-本讲学习什么（1分28秒）及第14讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404182535.png" alt="" /></p>
<h2 id="1401-什么是函数依赖9分27秒"><a class="header" href="#1401-什么是函数依赖9分27秒">1401-什么是函数依赖（9分27秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404182758.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404182904.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183025.png" alt="" /></p>
<h2 id="1402-部分函数依赖与完全函数依赖4分40秒"><a class="header" href="#1402-部分函数依赖与完全函数依赖4分40秒">1402-部分函数依赖与完全函数依赖（4分40秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183103.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183156.png" alt="" /></p>
<h2 id="1403-传递函数依赖3分57秒"><a class="header" href="#1403-传递函数依赖3分57秒">1403-传递函数依赖（3分57秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183438.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183458.png" alt="" /></p>
<h2 id="1404-函数依赖相关的几个重要概念8分17秒"><a class="header" href="#1404-函数依赖相关的几个重要概念8分17秒">1404-函数依赖相关的几个重要概念（8分17秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183526.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183605.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183644.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183729.png" alt="" /></p>
<h2 id="1405-关于函数依赖的armstrong公理8分05秒"><a class="header" href="#1405-关于函数依赖的armstrong公理8分05秒">1405-关于函数依赖的Armstrong公理（8分05秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183904.png" alt="" /></p>
<h2 id="1406-什么是属性集闭包6分01秒"><a class="header" href="#1406-什么是属性集闭包6分01秒">1406-什么是属性（集）闭包（6分01秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404183947.png" alt="" /></p>
<h2 id="1407-属性闭包的计算算法与覆盖及其证明7分53秒"><a class="header" href="#1407-属性闭包的计算算法与覆盖及其证明7分53秒">1407-属性闭包的计算算法与覆盖及其证明（7分53秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404184044.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404184107.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404184313.png" alt="" /></p>
<h2 id="1408-什么是最小覆盖6分08秒"><a class="header" href="#1408-什么是最小覆盖6分08秒">1408-什么是最小覆盖（6分08秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404184401.png" alt="" /></p>
<h2 id="第4讲总第14讲模拟题"><a class="header" href="#第4讲总第14讲模拟题">第4讲（总第14讲）模拟题</a></h2>
<p>7、关系模式R(A1，A2，A3，A4，A5，A6)，如果A1→(A3，A4)； (A2，A4)→A5； (A3，A5)→ A6，则关于R的说法正确的是_________。</p>
<ul>
<li>
<p>A.即不存在对候选键的部分函数依赖，又不存在对候选键的传递函数依赖</p>
</li>
<li>
<p>B.存在对候选键的部分函数依赖，但不存在对候选键的传递函数依赖</p>
</li>
<li>
<p>C.不存在对候选键的部分函数依赖，但存在对候选键的传递函数依赖</p>
</li>
<li>
<p>D.既存在对候选键的部分函数依赖，又存在对候选键的传递函数依赖</p>
</li>
</ul>
<p>正确答案：D你错选为C</p>
<p>问题解析：可以求得候选码为（A1,A2），因为A1→(A3，A4)，所以存在对候选键的部分函数依赖，因为候选码为（A1,A2),有(A1,A2）→（A1，A2，A3，A4，A5，A6）,又因为在依赖集中有（A3，A5）→A6，因此就会有（A1,A2）→（A3，A5）→A6即存在对候选键的传递函数依赖</p>
<p>15、已知关系R(A，B，C，D，E，F，G)，函数依赖集F为{ BC -&gt; AE，DC-&gt;EF，DG-&gt;E，B-&gt;CD，D-&gt;G }，问：F的最小覆盖为_________。</p>
<ul>
<li>
<p>A.{ BC-&gt;A，BC-&gt;E，DC-&gt;E，DC-&gt;F，DG-&gt;E，B-&gt;C，B-&gt;D，D-&gt;G }</p>
</li>
<li>
<p>B.{ B-&gt;A，DC-&gt;F，D-&gt;E，B-&gt;C，B-&gt;D，D-&gt;G }</p>
</li>
<li>
<p>C.{ B-&gt;A，B-&gt;E，D-&gt;E，B-&gt;C，B-&gt;D，D-&gt;G }</p>
</li>
<li>
<p>D.{ B-&gt;A，B-&gt;E，D-&gt;F，C-&gt;F，D-&gt;E，B-&gt;C，B-&gt;D，D-&gt;G }</p>
</li>
</ul>
<p>正确答案：B你错选为A</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240404185410.png" alt="" /></p>
<p>19、已知关系R(A，B，C，D，E，F，G)，函数依赖集F为{ ADG-&gt; EF，CD-&gt;F，F-&gt;B， A-&gt;D }，问：能从F中推导出的函数依赖是_________。</p>
<ul>
<li>
<p>A.ADG-&gt;E， AG-&gt;E</p>
</li>
<li>
<p>B.D-&gt;B，G-&gt;E</p>
</li>
<li>
<p>C.CD-&gt;B，AC-&gt;B，CDG-&gt;F，FE-&gt;CB</p>
</li>
<li>
<p>D.F-&gt;B，FA-&gt;D，A-&gt;EF</p>
</li>
</ul>
<p>正确答案：A你错选为C</p>
<p>解析：G-&gt;E、FE-&gt;CB、A-&gt;EF这些推导不出来</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第15讲-关系模式设计之规范形式"><a class="header" href="#第15讲-关系模式设计之规范形式">第15讲-关系模式设计之规范形式</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152551.png" alt="" /></p>
<h2 id="1500-本讲学习什么1分19秒及第15讲教学课件"><a class="header" href="#1500-本讲学习什么1分19秒及第15讲教学课件">1500-本讲学习什么（1分19秒）及第15讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402140928.png" alt="" /></p>
<h2 id="1501-什么是第一范式3分53秒"><a class="header" href="#1501-什么是第一范式3分53秒">1501-什么是第一范式（3分53秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402144016.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402144042.png" alt="" /></p>
<h2 id="1502-什么是第二范式6分40秒"><a class="header" href="#1502-什么是第二范式6分40秒">1502-什么是第二范式（6分40秒）</a></h2>
<p>目的：消除非受控冗余</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402144103.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402144126.png" alt="" /></p>
<h2 id="1503-什么是第三范式6分40秒"><a class="header" href="#1503-什么是第三范式6分40秒">1503-什么是第三范式（6分40秒）</a></h2>
<p>目的：消除非受控冗余</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402144212.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402144243.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402144308.png" alt="" /></p>
<h2 id="1504-什么是boyce-codd范式6分19秒"><a class="header" href="#1504-什么是boyce-codd范式6分19秒">1504-什么是Boyce-Codd范式（6分19秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152206.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152228.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152253.png" alt="" /></p>
<h2 id="1505-什么是多值依赖9分31秒"><a class="header" href="#1505-什么是多值依赖9分31秒">1505-什么是多值依赖（9分31秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152317.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152334.png" alt="" /></p>
<h2 id="1506选修-关于多值依赖的armstrong公理14分40秒"><a class="header" href="#1506选修-关于多值依赖的armstrong公理14分40秒">1506（选修）-关于多值依赖的Armstrong公理（14分40秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152354.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152444.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152507.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240402152526.png" alt="" /></p>
<h2 id="第5讲总第15讲模拟题"><a class="header" href="#第5讲总第15讲模拟题">第5讲（总第15讲）模拟题</a></h2>
<p>1、关系数据库规范化是为了解决关系数据库中插入问题、删除问题和数据冗余的问题而引入的。</p>
<p>11、已知关系模式R（A，B，C），函数依赖集F={B→C, B→A, A→BC}。则关于R，说
法正确的是？</p>
<p>解析：首先确定候选键，候选键为A能完全决定所有属性，B也能完全决定所有属性，所以A和B为候选键，非主属性为C。再进一步判断不存在部分函数依赖，不存在传递依赖，所以满足第2和第3范式。再看有没有不依赖于候选键的函数依赖，也不存在，故此R满足Boyce-Codd范式。</p>
<p>19、在R（XY）中，如果X→Y，并且对于X的某一个真子集X’，有X’→Y，则X为关系R的超码。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第16讲-模式分解存在什么问题"><a class="header" href="#第16讲-模式分解存在什么问题">第16讲-模式分解存在什么问题</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213755.png" alt="" /></p>
<h2 id="1600-本讲学习什么1分48秒及第16讲教学课件"><a class="header" href="#1600-本讲学习什么1分48秒及第16讲教学课件">1600-本讲学习什么（1分48秒）及第16讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403210118.png" alt="" /></p>
<h2 id="1601-模式分解存在的问题7分58秒"><a class="header" href="#1601-模式分解存在的问题7分58秒">1601-模式分解存在的问题（7分58秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403210406.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403210427.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403210456.png" alt="" /></p>
<h2 id="1602-无损连接分解及其检验算法14分48秒"><a class="header" href="#1602-无损连接分解及其检验算法14分48秒">1602-无损连接分解及其检验算法（14分48秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403210549.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403210638.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403210658.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403210724.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403211527.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403211548.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403211614.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403211638.png" alt="" /></p>
<h2 id="1603-保持依赖分解及其检验算法11分58秒"><a class="header" href="#1603-保持依赖分解及其检验算法11分58秒">1603-保持依赖分解及其检验算法（11分58秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213023.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213043.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213103.png" alt="" /></p>
<h2 id="1604-模式分解成bcnf及第3范式的算法11分43秒"><a class="header" href="#1604-模式分解成bcnf及第3范式的算法11分43秒">1604-模式分解成BCNF及第3范式的算法（11分43秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213421.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213439.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213524.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213548.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213609.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213632.png" alt="" /></p>
<h2 id="1605-连接依赖与第5范式3分05秒"><a class="header" href="#1605-连接依赖与第5范式3分05秒">1605-连接依赖与第5范式（3分05秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213652.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213712.png" alt="" /></p>
<h2 id="1606-数据库设计需要知道的6分50秒"><a class="header" href="#1606-数据库设计需要知道的6分50秒">1606-数据库设计需要知道的（6分50秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240403213735.png" alt="" /></p>
<h2 id="第6讲总第16讲模拟题"><a class="header" href="#第6讲总第16讲模拟题">第6讲（总第16讲）模拟题</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第17讲-数据库物理存储"><a class="header" href="#第17讲-数据库物理存储">第17讲-数据库物理存储</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407183420.png" alt="" /></p>
<h2 id="1700-第17讲本讲学习什么2分40秒及第17讲教学课件"><a class="header" href="#1700-第17讲本讲学习什么2分40秒及第17讲教学课件">1700-第17讲本讲学习什么（2分40秒）及第17讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407181248.png" alt="" /></p>
<h2 id="1701-存储体系回顾13分48秒"><a class="header" href="#1701-存储体系回顾13分48秒">1701-存储体系回顾（13分48秒）</a></h2>
<p>两个基本问题如何解决？</p>
<p>如何高效率的存储？——数据组织与索引</p>
<p>如何快速的检索？——查询实现与查询优化</p>
<p>面向大规模用户又如何解决？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407181516.png" alt="" /></p>
<h2 id="1702-磁盘的结构与特性17分19秒"><a class="header" href="#1702-磁盘的结构与特性17分19秒">1702-磁盘的结构与特性（17分19秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407181556.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407181651.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407182106.png" alt="" /></p>
<h2 id="1703-查询实现的基本思想12分41秒"><a class="header" href="#1703-查询实现的基本思想12分41秒">1703-查询实现的基本思想（12分41秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407182143.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407182203.png" alt="" /></p>
<h2 id="1704-记录与表在磁盘上的存储12分12秒"><a class="header" href="#1704-记录与表在磁盘上的存储12分12秒">1704-记录与表在磁盘上的存储（12分12秒）</a></h2>
<p>数据库记录在磁盘上的存储</p>
<p>定长记录，还是变长记录（靠分隔符区分开始与结束）</p>
<p>记录是非跨块存储，还是跨块存储（靠指针连接）</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407182434.png" alt="" /></p>
<h2 id="1705-四种文件组织方法16分01秒"><a class="header" href="#1705-四种文件组织方法16分01秒">1705-四种文件组织方法（16分01秒）</a></h2>
<p>（1）数据组织与存取方法</p>
<p>数据组织要考虑更新（增、删、改）和检索需求</p>
<ul>
<li>更新将涉及数据存储空间的扩展与回收问题</li>
<li>检索将涉及扫描整个数据库的问题、大批量处理数据问题</li>
<li>不同的需求要求不同的数据组织方法和存取方法</li>
<li>文件组织（File organization）指的是数据组织成记录、块和访问结构的方式，包括把记录和块存储在磁盘上的方式，以及记录和块之间相互联系的方法</li>
<li>存取方法（Access Method）指的是对文件所采取的存取操作方法</li>
<li>一种文件组织可以采取多种存取方法进行访问</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407182821.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407182908.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407183001.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407183026.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407183111.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407183141.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407183211.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407183251.png" alt="" /></p>
<h2 id="1706-oracle数据库物理存储简介14分43秒"><a class="header" href="#1706-oracle数据库物理存储简介14分43秒">1706-Oracle数据库物理存储简介（14分43秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240407183329.png" alt="" /></p>
<h2 id="第17讲模拟练习题"><a class="header" href="#第17讲模拟练习题">第17讲模拟练习题</a></h2>
<p>9、数据库重组是对数据表的物理存储进行调整。</p>
<p>12、在堆文件组织结构中，记录通常是以输入顺序存储的。</p>
<p>13、在顺序文件组织结构中，记录通常是按照某一键值的顺序（升序或降序）存储。</p>
<p>14、如果要将一批记录均匀地存储在n个数据块中，应采用散列文件组织结构。</p>
<p>解析：</p>
<p>顺序文件是按照某一键值的顺序（开序或降序）存储。</p>
<p>堆文件是无序记录文件，通常是按照记录的输入顺序存储的，但如要利用被删除记录的空间，则也可能将其插入到被删除记录的空间中。</p>
<p>散列文件是按照关于键值的某一散列函数值确定的位置进行存储，散列文件组织具有将一批记录均匀存储在 n 个数据块中的特性。</p>
<p>聚簇文件是将一个表或多个表的数据集中在一起进行存储。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第18讲-数据库索引技术"><a class="header" href="#第18讲-数据库索引技术">第18讲-数据库索引技术</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409181910.png" alt="" /></p>
<h2 id="1800-第18讲本讲学习什么2分01秒及第18讲教学课件"><a class="header" href="#1800-第18讲本讲学习什么2分01秒及第18讲教学课件">1800-第18讲本讲学习什么（2分01秒）及第18讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409152851.png" alt="" /></p>
<h2 id="1801-索引的概念和作用13分49秒"><a class="header" href="#1801-索引的概念和作用13分49秒">1801-索引的概念和作用（13分49秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409153357.png" alt="" /></p>
<p>(2)索引的一般性特点</p>
<p>索引文件是一种辅助存储结构，其存在与否不改变存储表的物理存储结构；然而其存在，可以明显提高存储表的访问速度。</p>
<p>索引文件组织方式有两种：（相对照的，主文件组织有堆文件、排序文件、散列文件、聚簇文件等多种方式）</p>
<ul>
<li>排序索引文件(Ordered indices):按索引字段值的某一种顺序组织存储</li>
<li>散列索引文件(Hash indices)：依据索引字段值使用散列函数分配散列桶的方式存储</li>
</ul>
<p>在一个表上可以针对不同的属性或属性组合建立不同的索引文件，可建立多个索引文件。索引字段的值可以是Table中的任何一个属性的值或任何多个属性值的组合值</p>
<p>索引文件比主文件小很多。通过检索一个小的索引文件(可全部装载进内存），快速定位后，再有针对性的读取非常大的主文件中的有关记录</p>
<p>有索引时，更新操作必须同步更新索引文件和主文件，否则可能无法成功搜索文件。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409154150.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409154237.png" alt="" /></p>
<h2 id="1802-sql中索引的创建和使用5分52秒"><a class="header" href="#1802-sql中索引的创建和使用5分52秒">1802-SQL中索引的创建和使用（5分52秒）</a></h2>
<p>(1)基本知识</p>
<p>SQL语言关于索引的基本知识</p>
<ul>
<li>当定义Table后，如果定义了主键，则系统将自动创建主索引，利用主索引对Table进行快速定位、检索与更新操作;</li>
<li>索引可以由用户创建，也可以由用户撤消</li>
<li>当索引被创建后，无论是主索引，还是用户创建的索引，DBMS都将自动维护所有的索引，使其与Table保持一致，即：当一条记录被插入到Table中后，所有索引也自动的被更新</li>
<li>当Table被删除后(drop table)，定义在该Table上的所有索引将自动被撤消</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409154818.png" alt="" /></p>
<p>(3）索引应用要注意效果</p>
<ul>
<li>选择哪些属性创建索引，以及如何创建与维护索引，如何利用索引改善数据库的运行性能，是DBA（数据库管理员）的重要职责。</li>
<li>是否建立和在哪些属性上建立索引需要考虑：访问时间、 插入时间、 删除时间与空间负载。 既要改善性能，又要控制代价。</li>
<li>建立索引还需考虑索引的类型：索引如何支持存取的有效性，比如：支持的是属性的限定值(是否符合单一值)，还是支持属性的限定范围的值(是否符合一定范围)</li>
</ul>
<p>对哪些属性建立索引？</p>
<p>对经常出现在检索条件、连接条件、分组计算条件中的属性可建立索引</p>
<p>SELECT...FROM...WHERE...GROUP BY..</p>
<h2 id="1803-稀疏索引与稠密索引10分58秒"><a class="header" href="#1803-稀疏索引与稠密索引10分58秒">1803-稀疏索引与稠密索引（10分58秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409155506.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409160536.png" alt="" /></p>
<p>（3）稠密索引如何定位记录</p>
<p>候选键属性的稠密索引一先查索引，然后再依据索引读主文件</p>
<p>无论是候选键属性的稠密索引，还是非候选键属性的稠密索引：索引文件中不存在搜索码的值，就代表着主文件中没有对应搜索码的记录</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409163531.png" alt="" /></p>
<h2 id="1804-主索引与辅助索引6分31秒"><a class="header" href="#1804-主索引与辅助索引6分31秒">1804-主索引与辅助索引（6分31秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409163746.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409163925.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409164037.png" alt="" /></p>
<h2 id="1805-聚簇索引与倒排索引8分32秒"><a class="header" href="#1805-聚簇索引与倒排索引8分32秒">1805-聚簇索引与倒排索引（8分32秒）</a></h2>
<p>（1）聚簇索引和非聚簇索引</p>
<p>聚簇索引是指索引中邻近的记录在主文件中也是临近存储的</p>
<p>非聚簇索引是指索引中邻近的记录在主文件中不一定是邻近存储的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409164347.png" alt="" /></p>
<p>聚簇索引是指索引中邻近的记录在主文件中也是临近存储的；</p>
<p>非聚簇索引是指索引中邻近的记录在主文件中不一定是邻近存储的。</p>
<ul>
<li>如果主文件的某一排序字段不是主码，则该字段上每个记录取值便不唯一，此时该字段被称为聚簇字段；聚簇索引通常是定义在聚簇字段上。</li>
<li>聚簇索引通常是对聚簇字段上的每一个不同值有一个索引项（索引项的总数和主文件中聚簇字段上不同值的数目相同），索引字段即是聚簇字段的不同值，由于有相同聚簇字段值的记录可能存储于若干块中，则索引项的指针指向其中的第一个块。</li>
<li>一个主文件只能有一个聚簇索引文件，但可以有多个非聚簇索引文件</li>
<li>主索引通常是聚簇索引(但其索引项总数不一定和主文件中聚簇字段上不同值的数目相同，其和主文件存储块数目相同）；辅助索引通常是非聚簇索引。</li>
<li>主索引/聚簇索引是能够决定记录存储位置的索引；而非聚簇索引则只能用于查询，指出已存储记录的位置。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409165002.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409165034.png" alt="" /></p>
<h2 id="1806-b树索引3个视频总计20分50秒"><a class="header" href="#1806-b树索引3个视频总计20分50秒">1806-B+树索引（3个视频总计20分50秒）</a></h2>
<p>(1)多级索引</p>
<p>多级索引：当索引项比较多时，可以对索引再建立索引，依此类推，形成多级索引。</p>
<p>当某级索引不能一次性装入内存时，可对其再建立索引</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409165404.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170001.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170021.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170200.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170253.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170334.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170407.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170447.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170517.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170544.png" alt="" /></p>
<p>B树和B+树有什么区别？</p>
<ol>
<li>
<p>结构层次不同：B树是一种多路搜索树，每个节点包含多个子节点；而B+树是一种多路平衡搜索树，所有数据都存储在叶子节点，并且叶子节点之间用指针连接形成链表。</p>
</li>
<li>
<p>查询方式不同：在B树中，如果要查找一个关键字，可以在内部节点和叶子节点中都进行查找；而在B+树中，只能在叶子节点中进行查找。</p>
</li>
<li>
<p>插入与删除操作的影响范围不同：在B树中，插入和删除一个节点可能会导致整棵树的结构发生变化；而在B+树中，插入和删除只会影响到叶子节点，内部节点的结构不会变化。</p>
</li>
<li>
<p>范围查询的优势：由于B+树的所有数据都存储在叶子节点中且有序排列，并且叶子节点之间有指针连接，所以在B+树中进行范围查询效率更高。</p>
</li>
<li>
<p>更适合文件系统索引：由于B+树的数据都存储在叶子节点中，并且叶子节点之间有指针连接，更适合用于文件系统的索引结构。</p>
</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409170707.png" alt="" /></p>
<h2 id="1807-b树键值插入与删除-结点分裂与合并操作示例3个视频总计27分37秒"><a class="header" href="#1807-b树键值插入与删除-结点分裂与合并操作示例3个视频总计27分37秒">1807-B+树键值插入与删除-结点分裂与合并操作示例（3个视频总计27分37秒）</a></h2>
<p>插入键值为40的记录</p>
<p>（1）寻找保存键值记录的叶子结点</p>
<p>（2）应插入结点已满，则申请新结点</p>
<p>（3）同时调整应插入但未插入结点中的键值记录，使其均衡存放于两个叶结点中(分裂)</p>
<p>（4）调整指针使其指向新叶子结点</p>
<p>（5）寻找指向新叶子结点的非叶结点</p>
<p>（6）应插入结点已满，则申请新结点</p>
<p>（7）同时调整应插入但未插入结点的键值记录，使其均衡存放于两个非叶结点中(分裂)</p>
<p>（8）调整各结点指针使其指向正确</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409175414.png" alt="" /></p>
<p>删除键值为7的记录</p>
<p>（1）叶子结点中寻找等于键值的记录，删除相应的指针及主文件中对应的记录</p>
<p>（2）调整其左侧(或右侧)结点及本结点中的键值记录，使其均衡存放于两个叶结点中</p>
<p>（3）如有调整，则进一步调整其上层非叶结点，重新确定其键值，以满足大于等于键值的记录都在其右侧</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409175744.png" alt="" /></p>
<p>简单插入</p>
<p>先定位待插入键值的叶子结点：从根结点开始向下；检查叶子结点是否已满？</p>
<p>如未满，则可直接插入</p>
<p>如已满，则需分裂该结点为两个</p>
<p>如父结点已满，则如此继续将其分裂为两个结点，保存相应键值一直到根结点。如根结点也满则再生成新的根结点，结束。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409180111.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409180138.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409180208.png" alt="" /></p>
<h2 id="1808-散列索引12分52秒"><a class="header" href="#1808-散列索引12分52秒">1808-散列索引（12分52秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409180238.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409180333.png" alt="" /></p>
<p>(4)散列的问题</p>
<p>桶的数目M是固定值——静态散列索引</p>
<p>如果桶的数目M不变：M过大，则浪费；M过小，则将产生更多的溢出桶增加散列索引检索的时间。</p>
<p>桶的数目随键值增多， 动态增加——动态散列索引</p>
<p>h(k)是和桶的数目M相关的。M的变化会否影响原来存储的内容呢？</p>
<p>是否需要将原来已经散列-存储的数据按新的桶数重新进行散列-存储呢？</p>
<h2 id="1809选修-可扩展散列索引和线性散列索引2个视频总计26分50秒"><a class="header" href="#1809选修-可扩展散列索引和线性散列索引2个视频总计26分50秒">1809（选修）-可扩展散列索引和线性散列索引（2个视频总计26分50秒）</a></h2>
<p>桶的数目随键值增多， 动态增加——动态散列索引</p>
<p>h(k)是和桶的数目M相关的。M的变化会否影响原来存储的内容呢？</p>
<p>是否需要将原来已经散列-存储的数据按新的桶数重新进行散列-存储呢？</p>
<p>可扩展散列索引</p>
<ul>
<li>为桶引入一间接层，即用一个指向块的指针数组来表示桶，而不是用数据块本身组成的数组来表示桶</li>
<li>指针数组能增长，其长度总是2的幂。因而数组每增长一次，桶的数目就翻倍。不过，并非每个桶都有一个数据块；如果某些桶中的所有记录可以放在一个块中，则这些桶可能共享一个块。</li>
<li>散列函数h为每个键计算出一个K位二进制序列，该K足够大，比如32。但是桶的数目总是使用从序列第一位或最后一位算起的若干位，此位数小于K,比如说i位。也就是说，当i是使用的位数时，桶数组将有<span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8247em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight">i</span></span></span></span></span></span></span></span></span></span></span>个项</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409181703.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409181725.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409181750.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409181819.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240409181847.png" alt="" /></p>
<h2 id="第18讲模拟练习题"><a class="header" href="#第18讲模拟练习题">第18讲模拟练习题</a></h2>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第19讲-数据库查询实现算法之一趟扫描算法"><a class="header" href="#第19讲-数据库查询实现算法之一趟扫描算法">第19讲-数据库查询实现算法之一趟扫描算法</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154955.png" alt="" /></p>
<h2 id="1900-第19讲本讲学习什么2分21秒及第19讲教学课件"><a class="header" href="#1900-第19讲本讲学习什么2分21秒及第19讲教学课件">1900-第19讲本讲学习什么（2分21秒）及第19讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413140127.png" alt="" /></p>
<h2 id="1901-查询实现算法概述18分06秒"><a class="header" href="#1901-查询实现算法概述18分06秒">1901-查询实现算法概述（18分06秒）</a></h2>
<p>查询优化不等于查询实现！</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413140556.png" alt="" /></p>
<h2 id="1902-由连接运算看查询实现的逻辑与物理算法2个视频总计19分07秒"><a class="header" href="#1902-由连接运算看查询实现的逻辑与物理算法2个视频总计19分07秒">1902-由连接运算看查询实现的逻辑与物理算法（2个视频总计19分07秒）</a></h2>
<h3 id="由连接运算看查询实现的逻辑与物理算法9分22秒"><a class="header" href="#由连接运算看查询实现的逻辑与物理算法9分22秒">由连接运算看查询实现的逻辑与物理算法（9分22秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413141300.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413141714.png" alt="" /></p>
<h3 id="连接运算的几个物理实现算法9分45秒"><a class="header" href="#连接运算的几个物理实现算法9分45秒">连接运算的几个物理实现算法（9分45秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413142729.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413143027.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413143617.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413143712.png" alt="" /></p>
<h2 id="1903--迭代器的概念与应用3个视频总计17分36秒"><a class="header" href="#1903--迭代器的概念与应用3个视频总计17分36秒">1903- 迭代器的概念与应用（3个视频总计17分36秒）</a></h2>
<h3 id="什么是和为什么要用迭代器8分25秒"><a class="header" href="#什么是和为什么要用迭代器8分25秒">什么是和为什么要用迭代器（8分25秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413144852.png" alt="" /></p>
<h3 id="利用迭代器构造查询实现算法6分04秒"><a class="header" href="#利用迭代器构造查询实现算法6分04秒">利用迭代器构造查询实现算法（6分04秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413153840.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154031.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154112.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154139.png" alt="" /></p>
<h3 id="利用迭代器构造连接操作实现算法"><a class="header" href="#利用迭代器构造连接操作实现算法">利用迭代器构造连接操作实现算法</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154236.png" alt="" /></p>
<h2 id="1904-查询实现的一趟扫描算法2个视频总计17分38秒"><a class="header" href="#1904-查询实现的一趟扫描算法2个视频总计17分38秒">1904-查询实现的一趟扫描算法（2个视频总计17分38秒）</a></h2>
<h3 id="查询实现的一趟扫描算法-去重复操作算法8分02秒"><a class="header" href="#查询实现的一趟扫描算法-去重复操作算法8分02秒">查询实现的一趟扫描算法-去重复操作算法（8分02秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154402.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154459.png" alt="" /></p>
<h3 id="查询实现的一趟扫描算法-其他操作算法9分36秒"><a class="header" href="#查询实现的一趟扫描算法-其他操作算法9分36秒">查询实现的一趟扫描算法-其他操作算法（9分36秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154525.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154545.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154608.png" alt="" /></p>
<h2 id="1905-基于索引的选择与连接算法2个视频总计9分35秒"><a class="header" href="#1905-基于索引的选择与连接算法2个视频总计9分35秒">1905-基于索引的选择与连接算法（2个视频总计9分35秒）</a></h2>
<h3 id="基于索引的选择算法5分31秒"><a class="header" href="#基于索引的选择算法5分31秒">基于索引的选择算法（5分31秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154649.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154826.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154905.png" alt="" /></p>
<h3 id="基于索引的连接算法4分04秒"><a class="header" href="#基于索引的连接算法4分04秒">基于索引的连接算法（4分04秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240413154933.png" alt="" /></p>
<h2 id="第19讲模拟练习题"><a class="header" href="#第19讲模拟练习题">第19讲模拟练习题</a></h2>
<p>4、下列关系代数操作，任何时候都能够用一趟算法实现的是______。</p>
<p>正确答案：B。解析：选择操作和包上的并操作，在征何时候都可以用一趟算法实现之。而
集合上的并操作则不一定能够用一趟算法实现之。故选项（B）是正确的</p>
<p>12、关于<strong>去</strong>重复&amp;(R)操作的一趟扫描算法，下列说法不正确的是____________。</p>
<ul>
<li>
<p>A.非精确的讲，算法的应用前提是B(R) &lt; =M，其中M为可用内存块数，B(R)为R中数据所占用的磁盘块数。</p>
</li>
<li>
<p>B.算法的关键是建立内存数据结构，可以建立散列结构，也可以建立排序结构，目的是进行快速比较。</p>
</li>
<li>
<p>C.算法可以做到只与一个内存块中的数据进行比较，即可判断出是否有重复。</p>
</li>
<li>
<p>D.算法需要首先对R的所有数据建立内存数据结构，然后才能判断是否有重复的元组存在。</p>
</li>
</ul>
<p>正确答案：D你错选为C</p>
<p>13、分组聚集操作的一趟扫描算法______________。</p>
<ul>
<li>
<p>A.非精确的讲，算法的应用前提是B(R) &lt; =M，其中M为可用内存块数，B(R)为R中数据所占用的磁盘块数</p>
</li>
<li>
<p>B.算法的关键是建立内存数据结构，可以建立散列结构，也可以建立排序结构，目的是进行快速比较</p>
</li>
<li>
<p>C.算法可以做到一条记录只与一个或少量几个内存块中的数据进行分组聚集计算</p>
</li>
<li>
<p>D.算法可以边执行边建立内存数据结构，即仅对已处理过的数据建立内存数据结构，便可进行各个分组的聚集计算</p>
</li>
</ul>
<p>正确答案：D你选对了</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第20讲-数据库查询实现算法之两趟扫描算法"><a class="header" href="#第20讲-数据库查询实现算法之两趟扫描算法">第20讲-数据库查询实现算法之两趟扫描算法</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415122033.png" alt="" /></p>
<h2 id="2000-第20讲本讲学习什么1分21秒及第20讲教学课件"><a class="header" href="#2000-第20讲本讲学习什么1分21秒及第20讲教学课件">2000-第20讲本讲学习什么（1分21秒）及第20讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415120527.png" alt="" /></p>
<h2 id="2001-两趟扫描算法的基本思想7分20秒"><a class="header" href="#2001-两趟扫描算法的基本思想7分20秒">2001-两趟扫描算法的基本思想（7分20秒）</a></h2>
<p>为什么需要两趟算法？</p>
<p>内存不够装载整个关系</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415120820.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415120917.png" alt="" /></p>
<h2 id="2002-两阶段多路归并排序算法2个视频总计16分41秒"><a class="header" href="#2002-两阶段多路归并排序算法2个视频总计16分41秒">2002-两阶段多路归并排序算法（2个视频总计16分41秒）</a></h2>
<h3 id="两阶段多路归并排序算法9分11秒"><a class="header" href="#两阶段多路归并排序算法9分11秒">两阶段多路归并排序算法（9分11秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121117.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121142.png" alt="" /></p>
<h3 id="两阶段多路归并排序算法过程模拟及讨论7分30秒"><a class="header" href="#两阶段多路归并排序算法过程模拟及讨论7分30秒">两阶段多路归并排序算法过程模拟及讨论（7分30秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121212.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121241.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121307.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121445.png" alt="" /></p>
<h2 id="2003-基于排序的两趟扫描算法8分58秒"><a class="header" href="#2003-基于排序的两趟扫描算法8分58秒">2003-基于排序的两趟扫描算法（8分58秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121528.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121556.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121615.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121635.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121703.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121730.png" alt="" /></p>
<h2 id="2004-基于散列的两趟扫描算法2个视频总计16分13秒"><a class="header" href="#2004-基于散列的两趟扫描算法2个视频总计16分13秒">2004-基于散列的两趟扫描算法（2个视频总计16分13秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121809.png" alt="" /></p>
<h3 id="基于散列的两趟扫描算法-去重与分组8分00秒"><a class="header" href="#基于散列的两趟扫描算法-去重与分组8分00秒">基于散列的两趟扫描算法-去重与分组（8分00秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121849.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121913.png" alt="" /></p>
<h3 id="基于散列的两趟扫描算法-并交差与连接8分13秒"><a class="header" href="#基于散列的两趟扫描算法-并交差与连接8分13秒">基于散列的两趟扫描算法-并交差与连接（8分13秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121935.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240415121956.png" alt="" /></p>
<h2 id="第20讲模拟练习题"><a class="header" href="#第20讲模拟练习题">第20讲模拟练习题</a></h2>
<p>1、已知内存共有8块，若要排序有70块的数据集，应如何组织，才能使磁盘读写次数最少。下列方案中磁盘读写次数最少的方案是________。</p>
<ul>
<li>
<p>A.方案I：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成9个已排序子集合（其中包含一个仅有6块的子集合）；(2)接着在9个子集合中选择3个子集合  (其中包含仅有6块的子集合)，进行一个三路归并，形成一个已排序子集合；(3)再将剩余5个子集合与刚才归并后形成的子集合，进行一个七路归并，形成最终的已排序集合。这个方案的磁盘读写次数最少。</p>
</li>
<li>
<p>B.方案II：(1)以7块为一个单位划分子集合，每个子集合进行内排序并存储，形成10个已排序子集合；(2)接着在10个子集合中任选5个子集合进行一个五路归并，形成一个已排序子集合；(3)再将剩余5个子集合与刚才归并后形成的子集合，进行一个六路归并，形成最终的已排序集合。这个方案的磁盘读写次数最少。</p>
</li>
<li>
<p>C.方案III：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成9个已排序子集合（其中包含一个仅有6块的子集合）；(2)接着在9个子集合中任选七个子集合进行一个七路归并，形成一个已排序子集合；(3)再将剩余2个子集合与刚才归并后形成的子集合，进行一个三路归并，形成最终的已排序集合。这个方案的磁盘读写次数最少。</p>
</li>
<li>
<p>D.方案IV：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成9个已排序子集合；(2)接着在9个子集合中任选5个子集合进行一个五路归并，形成一个已排序子集合；(3)再将剩余4个子集合与刚才归并后形成的子集合，进行一个五路归并，形成最终的已排序集合。这个方案的磁盘读写次数最少。</p>
</li>
</ul>
<p>正确答案：A你选对了</p>
<p>2、已知内存共有100块，若要排序有10000块的数据集，则该数据集不能在两趟内实现排序，磁盘读写次数为40400次。。</p>
<p>3、已知内存共有8块，若要排序有100块的数据集，则给定多路归并算法如下：(1)以8块为一个单位划分子集合，每个子集合进行内排序并存储，形成13个已排序子集合(含一个仅有4块的子集合)；(2)接着在13个子集合中任选7个子集合（包含仅有4块的子集合）进行一个七路归并，形成一个已排序子集合；(3)再将剩余6个子集合与刚才归并后形成的子集合，进行一个七路归并，形成最终的已排序集合。问：这个方案的磁盘读写次数是504。</p>
<p>4、关于基于排序的两趟算法，下列说法都正确：</p>
<p>基于排序的两趟算法的第一趟都是划分子表并排序。每一个子表应都能装入内存，并进行排序，然后再存回磁盘。</p>
<p>基于排序的两趟算法的第二趟是进行归并，在归并的过程中可以边排序边去重复，归并完成即去重复操作完成。</p>
<p>基于排序的两趟算法的第二趟是进行归并，在归并的过程中可以一边排序一边进行分组并进行聚集计算，归并完成即分组聚集计算操作完成。</p>
<p>5、已知关系R和S。关系占用的磁盘块数B(R)=1000，B(S)=1000，已知可用内存页数M=40。采用基于排序的算法，下列说法正确的是用一趟算法即可实现R和S的包的并操作。</p>
<p>6、已知关系R和S。关系占用的磁盘块数B(R)=1000，B(S)=500，已知可用内存页数M=50。采用基于排序的算法，下列说法正确的是用两趟算法才能实现R和S的集合并操作。</p>
<p>7关于基于散列的两趟算法，下列说法都正确：</p>
<p>基于散列的两趟算法的第一趟是散列子表。用某一个散列函数，将具有相同散列值的元组散列到相同的子表中并存回磁盘。</p>
<p>基于散列的两趟算法的第二趟是用与第一趟不同的散列函数，将子表再散列到内存的不同内存块中，在具有相同散列值的所有内存块中去重复，即是在整个关系上去重复。所有子表处理完成，去重复操作即告完成。</p>
<p>两次散列函数的选择是不同的，第一趟是在大范围上进行散列，将一个大数据集散列成若干个具有相同散列值的散列子表，第二趟是在小范围上进行散列，将具有某相同散列值的散列子表(大范围上散列值相等)散列到内存的某一块或几块(小范围上散列值相等)。</p>
<p>8、基于散列的两趟算法和基于排序的两趟算法，其中第一趟都是划分子表，都要求子表的存储块数要小于可用内存数，以便子表可以一次性装入内存进行处理。关于划分子表，下列说法正确的是基于排序的算法总是可以均匀地划分子表(即每个子表的大小都一样，除最后一块外)；基于散列的算法不能保证总是均匀地划分子表。</p>
<p>9、关于R与S的并、交、差运算的基于散列的两趟算法，其中第一趟都是划分子表，都要求子表的存储块数要小于可用内存块数，以便子表可以一次性装入内存进行处理。关于划分子表，下列说法正确的是必须用相同的散列函数将R和S分别散列成若干个子表。</p>
<p>10、关于基于散列的两趟算法和基于排序的两趟算法的基本思想，下列说法正确的是排序算法是先划分子表，独立处理子表（第一趟），然后再对各子表进行关联性处理（第二趟）；散列算法是先从关联性角度处理，形成子表（第一趟），然后再独立处理每一个子表（第二趟）。</p>
<p>11、关于连接运算R (JOIN on R.A=S.B) S的基于散列的两趟算法，下列说法不正确的是_______。</p>
<ul>
<li>
<p>A.必须以相同的散列函数分别散列R和S，形成若干个散列子表。</p>
</li>
<li>
<p>B.散列过程中，R必须以A属性值作为散列函数的键值，S必须以B属性值作为散列函数的键值。</p>
</li>
<li>
<p>C.散列过程中，R必须以A和B属性值作为散列函数的键值，S也必须以A和B属性值作为散列函数的键值。</p>
</li>
<li>
<p>D.第二趟处理中，须将R的子表再完整地散列到内存的若干块中，然后再一块一块处理S对应子表的每一块，以便快速决定可以连接的元组。</p>
</li>
</ul>
<p>正确答案：C你选对了</p>
<p>12、关于基于散列的两趟算法，下列说法正确的是第一趟散列的目的是使数据子集具有某一种特性(如具有相同的散列值)，而第二趟散列的目的是提高数据处理的速度。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第21讲-数据库查询优化技术"><a class="header" href="#第21讲-数据库查询优化技术">第21讲-数据库查询优化技术</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140656.png" alt="" /></p>
<h2 id="2100-第21讲本讲学习什么1分25秒及第21讲教学课件"><a class="header" href="#2100-第21讲本讲学习什么1分25秒及第21讲教学课件">2100-第21讲本讲学习什么（1分25秒）及第21讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125320.png" alt="" /></p>
<h2 id="2101-什么是查询优化6分22秒"><a class="header" href="#2101-什么是查询优化6分22秒">2101-什么是查询优化（6分22秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125431.png" alt="" /></p>
<p>查询优化</p>
<p>如何使数据库查询的执行时间最短？</p>
<p>三个层面进行优化：</p>
<ul>
<li>语义优化：利用模型的语义及完整性规则，优化查询</li>
<li>语法优化---逻辑层优化：利用语法结构，优化操作执行顺序；</li>
<li>执行优化---物理层优化：存取路径和执行算法的选择与执行次序优化；</li>
</ul>
<h2 id="2102-查询优化的总体思路13分31秒"><a class="header" href="#2102-查询优化的总体思路13分31秒">2102-查询优化的总体思路（13分31秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125755.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125822.png" alt="" /></p>
<p>尽可能早的做选择操作，可有效地减少中间结果元组的数目。</p>
<p>尽可能早的做投影操作，可有效地减少中间结果所占用的内存块的数目。</p>
<p>将笛卡尔积操作与其后的选择操作组合成连接操作，可有效地减少中间结果元组的数目。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125844.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125904.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125942.png" alt="" /></p>
<h2 id="2103-逻辑层查询优化策略13分50秒"><a class="header" href="#2103-逻辑层查询优化策略13分50秒">2103-逻辑层查询优化策略（13分50秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125844.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416130123.png" alt="" /></p>
<h2 id="2104-关系代数操作等价变换定理2个视频总计22分16秒"><a class="header" href="#2104-关系代数操作等价变换定理2个视频总计22分16秒">2104-关系代数操作等价变换定理（2个视频总计22分16秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416130157.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140007.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140031.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140051.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140115.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140137.png" alt="" /></p>
<p>将左侧公式变换为右侧公式，表示将两趟扫描数据库（左侧），变成一趟扫描数据库（右侧）。</p>
<p>将右侧公式变换为左侧公式，表示将复杂条件的选择操作（右侧），变成简单条件的选择操作（左侧）。</p>
<p>在逻辑优化起始，应首先将右侧形式的公式转变为左侧形式的公式。</p>
<p>在逻辑优化结束前，应将左侧形式的公式转变为右侧形式的公式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140200.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140232.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140256.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140326.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416140533.png" alt="" /></p>
<p>因为先做差运算再投影，和先投影再做差运算，结果可能不一样，你可比较以下：假设上式的n=3，即投影三个属性，而E和E有6个属性。六个属性上的差运算和三个属性上的差运算结果可能是不同的。</p>
<h2 id="2105-基于关系代数的查询优化算法13分44秒"><a class="header" href="#2105-基于关系代数的查询优化算法13分44秒">2105-基于关系代数的查询优化算法（13分44秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416135815.png" alt="" /></p>
<h2 id="2106-物理层查询优化13分19秒"><a class="header" href="#2106-物理层查询优化13分19秒">2106-物理层查询优化（13分19秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416135647.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416135710.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416125904.png" alt="" /></p>
<h2 id="2107-代价估算2个视频总计15分39秒"><a class="header" href="#2107-代价估算2个视频总计15分39秒">2107-代价估算（2个视频总计15分39秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416135600.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416130639.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240416130536.png" alt="" /></p>
<h2 id="第21讲模拟练习题"><a class="header" href="#第21讲模拟练习题">第21讲模拟练习题</a></h2>
<p>1、关于逻辑查询优化和物理查询优化，下列说法正确的是逻辑查询优化是关系代数操作次序的优化；物理查询优化是关系代数操作实现算法选择的优化。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第22讲-数据库事务处理技术之并发控制"><a class="header" href="#第22讲-数据库事务处理技术之并发控制">第22讲-数据库事务处理技术之并发控制</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121424.png" alt="" /></p>
<h2 id="2200-第22讲本讲学习什么1分45秒及第22讲教学课件"><a class="header" href="#2200-第22讲本讲学习什么1分45秒及第22讲教学课件">2200-第22讲本讲学习什么（1分45秒）及第22讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418190201.png" alt="" /></p>
<h2 id="2201-为什么要进行并发控制8分56秒"><a class="header" href="#2201-为什么要进行并发控制8分56秒">2201-为什么要进行并发控制（8分56秒）</a></h2>
<p>为什么要进行并发控制？</p>
<p>（1）数据库可能存在不一致</p>
<p>如果大家同时买起点终点、日期、 车次相同的车票，会否买到座位相重复的车票？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418190342.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418191114.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418191153.png" alt="" /></p>
<h2 id="2202-深入认识事务2个视频总计15分48秒"><a class="header" href="#2202-深入认识事务2个视频总计15分48秒">2202-深入认识事务（2个视频总计15分48秒）</a></h2>
<h3 id="深入认识事务9分59秒"><a class="header" href="#深入认识事务9分59秒">深入认识事务（9分59秒）</a></h3>
<p>（1）事务的概念</p>
<p>事务（Transaction）是数据库管理系统提供的控制数据操作的一种手段，通过这一手段，应用程序员将一系列的数据库操作组合在一起作为一个整体进行操作和控制，以便数据库管理系统能够提供一致性状态转换的保证。</p>
<p>（2）事务的宏观性和微观性</p>
<p>事务的宏观性 (应用程序员看到的事务)：一个存取或改变数据库内容的程序的一次执行，或者说一条或多条SQL语句的一次执行被看作一个事务。</p>
<p>事务一般是由应用程序员提出，因此有开始和结束，结束前需要提交或撤消。</p>
<pre><code class="language-c">Begin Transaction
exec sql ...
exec sql ..
exec sql commit work I exec sql rollback work
End Transaction
</code></pre>
<p>在嵌入式SQL程序中，任何一条数据库操纵语句（如 exec sql select 等)都会引发一个新事务的开
始，只要该程序当前没有正在处理的事务。而事务的结束是需要应用程序员通过 commit 或
rollback 确认的。 因此 Begin Transaction 和 End Transaction两行语句是不需要的。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418191639.png" alt="" /></p>
<p>事务的微观性（DBMS看到的事务）：对数据库的一系列基本操作（读、写）的一个整体性执行。</p>
<pre><code>T: read(A);
A:= A - 5000;
write(A);
read(B);
B:= B + 5000;
write(B);
</code></pre>
<p>事务的并发执行：多个事务从宏观上看是并行执行的，但其微观上的基本操作（读、写）则可以是交叉执行的</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418191800.png" alt="" /></p>
<h3 id="事务acid特性5分49秒"><a class="header" href="#事务acid特性5分49秒">事务ACID特性（5分49秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418191832.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418191909.png" alt="" /></p>
<h2 id="2203-事务调度与可串行性3个视频总计22分39秒"><a class="header" href="#2203-事务调度与可串行性3个视频总计22分39秒">2203-事务调度与可串行性（3个视频总计22分39秒）</a></h2>
<h3 id="事务调度与可串行性8分45秒"><a class="header" href="#事务调度与可串行性8分45秒">事务调度与可串行性（8分45秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419113805.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419114025.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419114144.png" alt="" /></p>
<p>注意：这里应该是并发调度，不是并行调度！</p>
<p>（2）一种简单的事务调度的标记模型</p>
<p>表达事务调度的一种模型</p>
<p>r_T(A): 事务T读A。 W_T(A) : 事务T写A</p>
<p>T1: r1(A); W1(A); r1(B); w1(B)</p>
<p>T2: r2(A); W2(A); r2(B); W2(B)</p>
<h3 id="冲突可串行性7分44秒"><a class="header" href="#冲突可串行性7分44秒">冲突可串行性（7分44秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419114639.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115100.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115141.png" alt="" /></p>
<h3 id="冲突可串行性判别算法6分10秒"><a class="header" href="#冲突可串行性判别算法6分10秒">冲突可串行性判别算法（6分10秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115213.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115359.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115456.png" alt="" /></p>
<h2 id="2204-基于锁的并发控制3个视频总计30分57秒"><a class="header" href="#2204-基于锁的并发控制3个视频总计30分57秒">2204-基于锁的并发控制（3个视频总计30分57秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115532.png" alt="" /></p>
<h3 id="什么是锁6分14秒"><a class="header" href="#什么是锁6分14秒">什么是锁（6分14秒）</a></h3>
<p>基于封锁的并发控制方法</p>
<p>（2）什么是锁?</p>
<p>"锁" 是控制并发的一种手段</p>
<p>每一数据元素都有唯一的锁</p>
<p>每一事务读写数据元素前，要获得锁</p>
<p>如果被其他事务持有该元素的锁，则要等待。</p>
<p>事务处理完成后要释放锁</p>
<p>L_i(A): 事务T_i对数据元素A加锁</p>
<p>U_i(A): 事务T_i对数据元素A解锁</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115748.png" alt="" /></p>
<p>调度器可利用锁来保证冲突可串行性</p>
<p>锁本身并不能保证冲突可串行性。</p>
<p>锁为调度提供了控制的手段。但如何用锁，仍需说明。---不同的协议</p>
<h3 id="封锁协议要考虑什么13分57秒"><a class="header" href="#封锁协议要考虑什么13分57秒">封锁协议要考虑什么（13分57秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115911.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419115939.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120004.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120023.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120043.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120108.png" alt="" /></p>
<h3 id="两段封锁协议10分46秒"><a class="header" href="#两段封锁协议10分46秒">两段封锁协议（10分46秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120144.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120208.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120232.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120250.png" alt="" /></p>
<h2 id="2205-基于时间戳的并发控制2个视频19分33秒"><a class="header" href="#2205-基于时间戳的并发控制2个视频19分33秒">2205-基于时间戳的并发控制（2个视频19分33秒）</a></h2>
<h3 id="基于时间戳的并发控制10分40秒"><a class="header" href="#基于时间戳的并发控制10分40秒">基于时间戳的并发控制（10分40秒）</a></h3>
<p>（2）什么是时间戳?</p>
<p>时间戳(TIMESTAMP)</p>
<p>一种基于时间的标志，将某一时刻转换成的一个数值。</p>
<p>时间戳具有唯一性和递增性。</p>
<p>事务的时间戳</p>
<p>事务T启动时，系统将该时刻赋予T，为T的时间戳</p>
<p>时间戳可以表征一系列事务执行的先后次序：时间戳小的事务先执行，时间戳大的事务后执行。</p>
<p>利用时间戳，可以不用锁来进行并发控制</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120442.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120506.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120653.png" alt="" /></p>
<p>核心思想：先执行的先操作，后执行的后操作，这样没有冲突</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120739.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120816.png" alt="" /></p>
<h3 id="基于时间戳的另一种调度8分53秒"><a class="header" href="#基于时间戳的另一种调度8分53秒">基于时间戳的另一种调度（8分53秒）</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120846.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120906.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120924.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419120947.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121005.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121029.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121049.png" alt="" /></p>
<h2 id="2206-基于有效性确认的并发控制14分23秒"><a class="header" href="#2206-基于有效性确认的并发控制14分23秒">2206-基于有效性确认的并发控制（14分23秒）</a></h2>
<p>能否进行批量性的冲突检测？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121146.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121214.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121229.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121245.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121307.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121341.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419121402.png" alt="" /></p>
<h2 id="第22讲模拟练习题"><a class="header" href="#第22讲模拟练习题">第22讲模拟练习题</a></h2>
<p>13、T1，T2，T3三个事务，记wi(A)为事务Ti写数据对象A，ri(A)为事务Ti读数据对象A，一个调度S为 “<strong>w1(Y); w2(Y); w2(X); w1(X); w3(X);</strong>”，问该调度是S不是冲突可串行化调度，但却是可串行化调度，是正确的并行调度。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240419114025.png" alt="" /></p>
<p>要判断给定的调度S是否是正确的并发调度以及是否是可串行调度，我们需要考虑事务之间的数据依赖关系和执行顺序。</p>
<p>首先，让我们逐步分析该调度：</p>
<ol>
<li>T1写入了数据对象Y（w1(Y)）。</li>
<li>T2写入了数据对象Y（w2(Y)）。</li>
<li>T2写入了数据对象X（w2(X)）。</li>
<li>T1写入了数据对象X（w1(X)）。</li>
<li>T3读取了数据对象X（r3(X)）。</li>
</ol>
<p>现在，让我们来分析一下：</p>
<p><strong>正确的并发调度</strong>：</p>
<ul>
<li>如果在该并发调度中，没有出现任何事务的读写冲突、写写冲突和不可重复读现象，则可以认为是一个正确的并发调度。</li>
</ul>
<p>在给定的调度中，不存在两个事务同时访问相同的数据对象的情况，因此没有出现读写冲突或写写冲突。因此，这是一个正确的并发调度。</p>
<p><strong>可串行调度</strong>：</p>
<ul>
<li>如果该并发调度的执行结果与某个串行调度的执行结果相同，则称该并发调度是可串行的。</li>
</ul>
<p>一个串行调度可以是w1(Y); w2(Y); w2(X); w1(X); w3(X)。在这个串行调度中，T1和T2的写操作按照其在调度S中的顺序执行，然后T3读取了X。调度S的执行结果与这个串行调度的执行结果相同，因此调度S是可串行的。</p>
<p>综上所述，给定的调度S是一个正确的并发调度，并且是可串行的。</p>
<p>这个调度S为：“<strong>w1(Y); w2(Y); w2(X); w1(X); w3(X);</strong>”</p>
<p>首先，我们来看这个调度是否是正确的并发调度。一个正确的并发调度必须满足以下两个条件：</p>
<ol>
<li>
<p><strong>事务操作的顺序不变</strong>：在调度S中，事务的操作顺序是不变的，即按照w1(Y), w2(Y), w2(X), w1(X), w3(X)的顺序执行。</p>
</li>
<li>
<p><strong>事务操作必须保证数据一致性</strong>：对于每个数据对象，如果事务Ti写入了一个数据项后，再有其他事务Tj读取或者写入该数据项时，Tj必须读取Ti的写入值。</p>
</li>
</ol>
<p>对于第一个条件，调度S满足，因为事务操作的顺序没有改变。</p>
<p>对于第二个条件，我们来逐步分析：</p>
<ol>
<li>w1(Y)：事务T1写入了数据对象Y。</li>
<li>w2(Y)：事务T2写入了数据对象Y。</li>
<li>w2(X)：事务T2写入了数据对象X。</li>
<li>w1(X)：事务T1写入了数据对象X。</li>
<li>w3(X)：事务T3写入了数据对象X。</li>
</ol>
<p>接下来判断这个调度是否是可串行调度。一个可串行调度是指，存在一个等价的串行调度，该串行调度与原调度S的操作序列相同。因为可串行调度是串行调度的特例，因此我们只需要验证是否存在一个串行调度等价于原调度S即可。</p>
<p>根据原调度S的操作序列，可以构建一个串行调度为：T1 -&gt; T2 -&gt; T3，即按照事务T1、T2、T3的顺序执行操作。</p>
<p>26、关于基于时间戳的并发控制方法(简称TS方法)和基于有效性确认的并发控制方法(简称VA方法)的异同点，下列说法不正确的是___________。</p>
<ul>
<li>
<p>A.TS方法和VA方法都是利用时间戳表征事务的启动时刻，表征事务的执行次序</p>
</li>
<li>
<p>B.TS方法和VA 方法都是为每一数据库元素保存一个读时间戳和写时间戳</p>
</li>
<li>
<p>C.TS方法是比较事务的时间戳与数据库元素的时间戳来判断是否有冲突，而VA方法是通过比较两个事务的读写数据集合是否有交集来判断是否有冲突</p>
</li>
<li>
<p>D.TS方法和VA方法都是以撤销事务并重启事务来解决事务之间的冲突</p>
</li>
</ul>
<p>正确答案：B你选对了</p>
<p>解析：选项A、C和D的说法都是正确的，但选项B的说法是不正确的，TS方法是为每一数据库元素保存一个读时间戳和写时间戳，以便于事务时间戳与数据库元素的时间戳进行比较判断冲突；而VA方法则是为每一个事务保存一个读数据集合和一个写数据集合，以便于数据集合之间的比较判断冲突，故选项B的说法是不正确的。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="第23讲-数据库事务处理技术之故障恢复"><a class="header" href="#第23讲-数据库事务处理技术之故障恢复">第23讲-数据库事务处理技术之故障恢复</a></h1>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418184519.png" alt="" /></p>
<h2 id="2300-第23讲本讲学习什么1分43秒及第23讲教学课件"><a class="header" href="#2300-第23讲本讲学习什么1分43秒及第23讲教学课件">2300-第23讲本讲学习什么（1分43秒）及第23讲教学课件</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418180841.png" alt="" /></p>
<h2 id="2301-数据库故障类型6分44秒"><a class="header" href="#2301-数据库故障类型6分44秒">2301-数据库故障类型（6分44秒）</a></h2>
<p>(1)你要知道的</p>
<p>DBMS 的运行方式：</p>
<ul>
<li>DBMS 利用内存（主存）和外存（辅存）这样的存储体系来进行数据库管理</li>
<li>在内存中，又将其分为程序数据（事务数据）和系统数据</li>
</ul>
<p>事务是DBMS对数据库进行控制的基本逻辑单元。</p>
<p>事务：宏观上是由程序员设置的一条或多条SQL语句的一次执行；微观上是对数据元素的一系列基本操作，如读写等。需要提交和撤销。</p>
<p>数据元素：</p>
<ul>
<li>通常 1 数据元素= 1 磁盘块/内存页</li>
<li>也可以更小 (=1 记录)或更大 (=1 关系)</li>
</ul>
<p>事务具有四个特性：ACID特性</p>
<ul>
<li>原子性 Atomicity</li>
<li>一致性 Consistency</li>
<li>隔离性 Isolation</li>
<li>持久性 Durability</li>
</ul>
<p>故障恢复涉及如何保证原子性和持久性</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418181352.png" alt="" /></p>
<h2 id="2302-数据库故障恢复的宏观思路12分10秒"><a class="header" href="#2302-数据库故障恢复的宏观思路12分10秒">2302-数据库故障恢复的宏观思路（12分10秒）</a></h2>
<p>(1)故障恢复与事务故障恢复</p>
<p>数据库故障恢复</p>
<p>把DB由当前不正确状态恢复到已知为正确的某一状态。</p>
<p>需要保证事务的：</p>
<p>√原子性：事务的所有操作，要么全都执行，要么全都不执行。</p>
<p>√持久性：已提交的事务对数据库产生的影响是持久的，未提交的事务对数据库不应有影响。</p>
<p>事务故障的恢复</p>
<p>事务故障可通过重做事务（Redo）和撤消事务（Undo）来恢复。重做事务可保证已提交事务的持久性，而撤销事务则消除未提交事务的影响</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418181616.png" alt="" /></p>
<p>系统故障可通过运行日志来恢复</p>
<p>按照运行日志记录的事务操作顺序重做事务（当事务在发生故障时已正确结束）或撤消事务（当事务在发生故障时未结束）</p>
<p>但故障恢复是需要时间的</p>
<p>运行日志保留了若干天的记录，当发生系统故障时应从哪一个点开始恢复呢？</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418181753.png" alt="" /></p>
<p>(3)介质故障恢复</p>
<p>副本(Copy)</p>
<ul>
<li>在某一时刻，对数据库在其他介质存储上产生的另一份等同记录</li>
<li>用副本替换被损坏的数据库</li>
</ul>
<p>介质故障的恢复</p>
<ul>
<li>用副本替换被破坏的数据库</li>
<li>由于介质故障影响全面，在用副本恢复后还需要依据运行日志进行恢复</li>
</ul>
<p>如何确定备份的时刻：转储点</p>
<ul>
<li>过频，影响系统工作效率；过疏，会造成运行日志过大，也影响系统运行性能</li>
<li>备份转储周期与运行日志的大小密切相关，应注意防止衔接不畅而引起的漏洞</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418182102.png" alt="" /></p>
<h2 id="2303-运行日志的概念13分57秒"><a class="header" href="#2303-运行日志的概念13分57秒">2303-运行日志的概念（13分57秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418182236.png" alt="" /></p>
<p>DBMS需要保证事务的：</p>
<p>√持久性：已提交的事务对数据库产生的影响是持久的，未提交的事务对数据库不应有影响。</p>
<p>√原子性：事务的所有操作，要么全都执行，要么全都不执行。</p>
<p>持久性：</p>
<p>已提交事务——缓冲区内容保证写回磁盘</p>
<p>未提交事务——缓冲区内容不能影响磁盘</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418182707.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418182842.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418182907.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418182933.png" alt="" /></p>
<h2 id="2304-undo型日志及其故障恢复9分59秒"><a class="header" href="#2304-undo型日志及其故障恢复9分59秒">2304-UNDO型日志及其故障恢复（9分59秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418183128.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418183223.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418183438.png" alt="" /></p>
<p>（4）检查点及其使用</p>
<p>静止检查点：周期性地对日志设置检查点</p>
<ul>
<li>停止接受新的事务， 等到所有当前活跃事务提交或终止，并在日志中写入了COMMIT或ABORT记录后</li>
<li>将日志刷新到磁盘，写入日志记录<code>&lt;CKPT&gt;</code>，并再次刷新日志</li>
</ul>
<p>非静止检查点</p>
<ul>
<li>在设置检查点时不必关闭系统，允许新事务进入</li>
<li>写入一条 <code>&lt;START CKPT(T1,...,Tk) &gt;</code>，其中T1,...,Tk是所有活跃的未结束的事务</li>
<li>继续正常的操作，直到T1,...,Tk都完成时，写入<code>&lt;ENDCKPT&gt;</code></li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418183745.png" alt="" /></p>
<h2 id="2305-redo型日志及其故障恢复7分54秒"><a class="header" href="#2305-redo型日志及其故障恢复7分54秒">2305-REDO型日志及其故障恢复（7分54秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418183826.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418183923.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418184006.png" alt="" /></p>
<p>（4）检查点及其运用</p>
<p>非静止检查点</p>
<p>在进行检查点设置时不必关闭系统，允许新事务进入</p>
<p>写入一条<code>&lt;START CKPT(T1,...,Tk) &gt;</code></p>
<p>其中T1,...,Tk是所有活跃的未结束的事务</p>
<p>将所有已提交的事务写回磁盘，继续正常的操作，直到T1,...,Tk都完成时，写入<code>&lt;ENDCKPT&gt;</code></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418184240.png" alt="" /></p>
<h2 id="2306-undoredo结合型日志及其故障恢复6分29秒"><a class="header" href="#2306-undoredo结合型日志及其故障恢复6分29秒">2306-UNDO/REDO结合型日志及其故障恢复（6分29秒）</a></h2>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418184316.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418184347.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418184427.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost02/img/20240418184504.png" alt="" /></p>
<h2 id="第23讲模拟练习题"><a class="header" href="#第23讲模拟练习题">第23讲模拟练习题</a></h2>
<p>1、日志文件是用于记录对数据的所有更新操作。</p>
<p>解析：数据库的日志是记录对数据的所有更新操作，使于当数据库出现故障时能够顺利的恢复，保证事务的原子性和持久性。</p>
<p>2、下列说法正确的是检查点是DBMS强制使内存DB Buffer中的内容与介质DB中的内容保持一致的时刻点。</p>
<p>3、介质故障的恢复需要_________。</p>
<ul>
<li>
<p>A.当前未执行完的事务撤销</p>
</li>
<li>
<p>B.当前执行完的事务需要按照运行日志记录的次序重做</p>
</li>
<li>
<p>C.用最新的备份文件替换发生故障的数据库文件</p>
</li>
<li>
<p>D.以上工作都需要，但需要注意操作的次序。</p>
</li>
</ul>
<p>正确答案：D你错选为C</p>
<p>4、检查点是故障恢复技术中出现的概念。</p>
<p>5、DBMS管理数据库缓冲区有四种策略：No Steal, Steal, No Force, Force。对这四种策略有下面四种解释。</p>
<ol>
<li>
<p>内存中的数据最晚在commit的时候写入磁盘；</p>
</li>
<li>
<p>内存中的数据可以一直保留，在commit之后过一段时间再写入磁盘；</p>
</li>
<li>
<p>允许在事务commit之前把内存中的数据写入磁盘；</p>
</li>
<li>
<p>不允许在事务commit之前把内存中的数据写入磁盘；</p>
</li>
</ol>
<p>则策略与解释有正确对应的是Force：1；  No Force：2；  Steal：3；  No Steal：4。</p>
<p>6、DBMS管理数据库缓冲区有四种策略：No Steal, Steal, No Force, Force。则效率较低但不会出现问题的策略组合是No Steal+ Force，而效率最高最常用但会出现问题的策略组合是Steal + No Force。</p>
<p>7、DBMS管理数据库缓冲区有四种策略：No Steal, Steal, No Force, Force。 为保证数据库系统故障能够有效地恢复，提出了三种类型的日志：Undo型日志、Redo型日志和Undo/Redo结合型日志。不同策略可以采用不同的日志予以恢复，则下列说法正确的是____________。</p>
<ul>
<li>
<p>A.Steal + Force：不需要任何日志，不需要恢复</p>
</li>
<li>
<p>B.No Steal + Force：需要Undo/Redo结合型日志进行恢复，不需要Redo型日志</p>
</li>
<li>
<p>C.No Steal + No Force：需要Redo型日志进行恢复，不需要Undo型日志</p>
</li>
<li>
<p>D.Steal+ No Force：需要Undo型日志进行恢复，      不需要Redo型日志</p>
</li>
</ul>
<p>正确答案：C你选对了</p>
<p>解析：本题需要理解这四种策略。Force+No Steal可以保证事务的持久性，不需恢复；</p>
<p>No Steal+No Force，会出现当发生系统故障时，已经提交事务却并未写入磁盘等问题，所以需要Redo型日志，以使重做事务保证持久性；</p>
<p>Steal+Force，会出现当发生系统故障时，未提交事务提早写入磁盘等问题，所以需要Undo型日志，以便撤销事务保证持久性；</p>
<p>而Steal+No Force，则在系统发生故障时，既会出现已经提交事务却并未写入磁盘等问题，也会出现未提交事务提早写入磁盘等问题，所以需要Undo/Redo结合型日志既执行已完成事务的重做，又执行未完成事务的撤销，才能保证持久性。</p>
<p>故此，选项C是正确的。</p>
<p>8、关于Undo型日志和Redo型日志的差别，下列说法正确的是Redo型日志是先将Commit记录写入日志，再将数据写回磁盘OUTPUT，而Undo型日志是先将数据写回磁盘OUTPUT，再将Commit记录写入日志。</p>
<p>9、关于用Undo型日志和Redo型日志进行数据库恢复，下列说法正确的是用Undo型日志恢复是从日志的尾部开始恢复，按日志记录的反序处理，直至遇到第一个检查点为止结束。</p>
<p>Redo型日志是先从日志尾部开始由后向前扫描直至遇到第一个检查点，然后自该检查点开始恢复，按日志记录正序处理，直至日志记录的尾部结束。</p>
<p>10、关于用Undo型日志进行数据库恢复，下列说法正确的是用Undo型日志恢复是对已完成的事务，跳过；而对未完成的事务，将日志记录的值写回磁盘。</p>
<p>Undo型日志仅保留了旧值，没有保留新值。</p>
<p>11、关于用Redo型日志进行数据库恢复，下列说法正确的是用Redo型日志恢复是对已完成的事务，将日志记录的值写回磁盘；而对未完成的事务，跳过。</p>
<p>Redo型日志仅保留了新值，没有保留旧值。</p>
<div style="break-before: page; page-break-before: always;"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="数据库存储过程"><a class="header" href="#数据库存储过程"><strong>数据库存储过程</strong></a></h1>
<p><strong>数据库存储过程定义</strong>：</p>
<p>数据库存储过程是一组预编译的SQL语句集合，可以被存储在数据库中并通过一个简单的调用来执行。存储过程可以接受参数、执行复杂的逻辑操作、返回结果集或输出参数。</p>
<p><strong>存储过程语法</strong>：</p>
<pre><code class="language-sql">CREATE PROCEDURE procedure_name AS BEGIN -- SQL statements END
</code></pre>
<p><strong>实例1：存储过程示例</strong></p>
<p><strong>自然语言描述存储功能</strong>：该存储过程用于根据客户ID查询客户信息。</p>
<p><strong>设计表结构</strong>：</p>
<pre><code class="language-sql">CREATE TABLE Customers (
    CustomerID INT PRIMARY KEY,
    CustomerName VARCHAR(50),
    Address VARCHAR(100)
)
</code></pre>
<p><strong>存储过程代码实现</strong>：</p>
<pre><code class="language-sql">CREATE PROCEDURE GetCustomerInfo
    @CustomerID INT
AS
BEGIN
    SELECT CustomerName, Address
    FROM Customers
    WHERE CustomerID = @CustomerID
END
</code></pre>
<p><strong>结果</strong>：调用存储过程<code>GetCustomerInfo</code>并传入客户ID，可以获取该客户的姓名和地址信息。</p>
<p><strong>实例2：存储过程示例</strong></p>
<p><strong>自然语言描述存储功能</strong>：该存储过程用于插入新的订单信息到订单表中。</p>
<p><strong>设计表结构</strong>：</p>
<pre><code class="language-sql">CREATE TABLE Orders (
    OrderID INT PRIMARY KEY,
    CustomerID INT,
    OrderDate DATE,
    TotalAmount DECIMAL(10, 2)
)
</code></pre>
<p><strong>存储过程代码实现</strong>：</p>
<pre><code class="language-sql">CREATE PROCEDURE InsertOrder
    @CustomerID INT,
    @OrderDate DATE,
    @TotalAmount DECIMAL(10, 2)
AS
BEGIN
    INSERT INTO Orders (CustomerID, OrderDate, TotalAmount)
    VALUES (@CustomerID, @OrderDate, @TotalAmount)
END
</code></pre>
<p><strong>结果</strong>：调用存储过程<code>InsertOrder</code>并传入客户ID、订单日期和总金额，可以向订单表中插入新的订单信息。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
